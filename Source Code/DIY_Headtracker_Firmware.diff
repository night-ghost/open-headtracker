diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/config.h DIY_Headtracker_Firmware_fastserial/DIY_headtracker/config.h
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/config.h	2017-05-28 19:08:38.126728302 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/config.h	2017-05-28 16:59:37.076471636 +0500
@@ -11,9 +11,27 @@
 // features.
 //
 
-// D2 - PPM input pin
-// Set to 1 to enable PPM input, 0 to disable. 
-#define PPM_IN  0
+// Define for extra debug serial info
+#define DEBUG 1
+//#define ECHO
+
+#define SAMPLERATE 100       // Samplerate of sensors (in hz, samples per second)
+
+#define PPM_OUT_PIN 9// PPM out on ICP1 - pin9
+
+
+#define PPM_IN  0    // Set to 1 to enable PPM input, 0 to disable. 
+#define PPM_IN_PIN 2 // PPM in on ICP0 - pin2
+
+//Connect A0 (analog_0) to pin2 (middle) of a 2K potentiometer, pin1 to +VCC, pin3 to GND.
+// #define ADC_PIN A0
+
+
+#define BUTTON_INPUT 11// PB4 (16) Center/pause input button pin number
+#define ARDUINO_LED  13// Arduino LED
+#define BUZZER       4 // PD4 (2) Pin definition for LED and buzzer (Fatshark goggles)
+
+
 
 // Button hold time for pause/unpause
 #define BUTTON_HOLD_PAUSE_THRESH    1500    // 1.5 second button hold required to pause/unpause tracking.
@@ -36,19 +54,18 @@
 //
 
 // Firmware Version, e.g. X.YY
-#define FIRMWARE_VERSION_FLOAT  1.04    // 2 decimal places
+#define FIRMWARE_VERSION_FLOAT  PSTR("1.04")    // 2 decimal places
 
 // Number of PPM channels out. 1 - 12 channels supported. 
-#define NUMBER_OF_CHANNELS 8
+#define NUMBER_OF_CHANNELS (10u)
 
-// Define for extra debug serial info
-#define DEBUG 0
 
 // Output serial data to host evern X frames
-#define SERIAL_OUTPUT_FRAME_INTERVAL    10
+#define SERIAL_OUTPUT_FRAME_INTERVAL    20
 
 // Serial communication speed. 
 #define SERIAL_BAUD 57600
+//#define SERIAL_BAUD 115200
 
 // Sensor board update-rate. Not done yet. 
 #define UPDATE_RATE 50
@@ -56,7 +73,7 @@
 // Dead-time between each channel in the PPM-stream. 
 #define DEAD_TIME 800
 
-// Sets the frame-length .
+// Sets the frame-length 
 #define FRAME_LENGTH (5003u + NUMBER_OF_CHANNELS * 5000u)
 
 // TOP (timer rollover) used for PPM pulse time measurement
@@ -65,18 +82,8 @@
 // Set to 0, stored gyro calibration is used. If 1, gyro is calibrated at powerup  
 #define ALWAYS_CAL_GYRO 0
 
-// Center/pause input button pin number
-#define BUTTON_INPUT 11
-
-// Arduino LED
-#define  ARDUINO_LED 13
 
-// Pin definition for LED and buzzer (Fatshark goggles)
-#if FATSHARK_HT_MODULE
-    #define  BUZZER      4
-#endif
-
-#define PPM_IN_MIN 1000 // 0.5 ms
+#define PPM_IN_MIN 900  // 0.5 ms
 #define PPM_IN_MAX 4000 // 2 ms
 
 // Settings stuff
diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/DIY_headtracker.ino DIY_Headtracker_Firmware_fastserial/DIY_headtracker/DIY_headtracker.ino
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/DIY_headtracker.ino	2017-05-28 19:05:47.312313209 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/DIY_headtracker.ino	2017-05-28 17:04:29.992077476 +0500
@@ -12,14 +12,15 @@
 //      Minor optimizations.
 //-----------------------------------------------------------------------------
 
+//#include <FastSerial.h>
+#include <SingleSerial.h>
+
 #include <Wire.h>
 #include "config.h"
 #include "functions.h"
 #include "sensors.h"
 #include <EEPROM.h>
 
-#include <SingleSerial.h>
-SingleSerialPort(Serial);
 /*
 Channel mapping/config for PPM out:
 
@@ -41,58 +42,42 @@ $123456789111CH
 */
 
 
+//FastSerialPort0(Serial);
+SingleSerialPort(Serial);
+
 // Local file variables
 //
 int frameNumber = 0;		    // Frame count since last debug serial output
 
 char serial_data[101];          // Array for serial-data 
-byte serial_index = 0; // How many bytes have been received?
+unsigned char serial_index = 0; // How many bytes have been received?
 char string_started = 0;        // Only saves data if string starts with right byte
-byte channel_mapping[14];
 
+/*
 char outputMag = 0;             // Stream magnetometer data to host
 char outputAcc = 0;             // Stream accelerometer data to host
+*/
 char outputMagAcc = 0;          // Stream mag and accell data (for calibration on PC)
 char outputTrack = 0;	        // Stream angle data to host
+char outputDbg=0;
 
 // Keep track of button press
 char lastButtonState = 0;           // 0 is not pressed, 1 is pressed
 unsigned long buttonDownTime = 0;   // the system time of the press
 char pauseToggled = 0;              // Used to make sure we toggle pause only once per hold
-char ht_paused = 0;
+byte ht_paused = 0;
 
 // External variables (defined in other files)
 //
-extern unsigned char PpmIn_PpmOut[13];
 extern char read_sensors;
 extern char resetValues;   
-extern char tiltInverse;
-extern char rollInverse;
-extern char panInverse;
 
 // Settings (Defined in sensors.cpp)
-//
-extern float tiltRollBeta;
-extern float panBeta;
-extern float gyroWeightTiltRoll;
-extern float GyroWeightPan;
-extern int servoPanCenter;
-extern int servoTiltCenter;
-extern int servoRollCenter;
-extern int panMaxPulse;
-extern int panMinPulse;
-extern int tiltMaxPulse;
-extern int tiltMinPulse;
-extern int rollMaxPulse;
-extern int rollMinPulse;
-extern float panFactor;
-extern float tiltFactor;  
-extern float rollFactor;
-extern unsigned char servoReverseMask;
-extern unsigned char htChannels[];
-extern float gyroOff[];
-extern float magOffset[];
-extern int accOffset[]; 
+extern settings sets;
+
+float dynFactor=1;
+
+
 // End settings   
 
 //--------------------------------------------------------------------------------------
@@ -104,25 +89,10 @@ void setup()
 {
     Serial.begin(SERIAL_BAUD);
 
+    pinMode(PPM_OUT_PIN,OUTPUT); 
   
-    pinMode(9,OUTPUT);
-    digitalWrite(2,HIGH);
-    digitalWrite(3,HIGH);  
-  
-    // Set all other pins to input, for safety.
-    pinMode(0,INPUT);
-    pinMode(1,INPUT);
-    pinMode(2,INPUT);
-    pinMode(3,INPUT);
-    pinMode(6,INPUT);
-    pinMode(7,INPUT);  
-    pinMode(8,INPUT);    
-
-    // Set button pin to input:
-    pinMode(BUTTON_INPUT,INPUT);
-  
-    // Set internal pull-up resistor. 
-    digitalWrite(BUTTON_INPUT,HIGH);
+    pinMode(BUTTON_INPUT,INPUT);// Set button pin to input:
+    digitalWrite(BUTTON_INPUT,HIGH);// Set internal pull-up resistor. 
   
     digitalWrite(0,LOW); // pull-down resistor
     digitalWrite(1,LOW);
@@ -132,37 +102,21 @@ void setup()
     pinMode(ARDUINO_LED,OUTPUT);    // Arduino LED
     digitalWrite(ARDUINO_LED, HIGH);
     
-#if FATSHARK_HT_MODULE
-    pinMode(BUZZER,OUTPUT);         // Buzzer
-    digitalWrite(BUZZER, HIGH);
-#endif
 
-    // Give it time to be noticed, then turn it off
-    delay(200); // Note: only use delay here. This won't work when Timer0 is repurposed later.
-    digitalWrite(ARDUINO_LED, LOW);
+    Wire.begin();               // Start I2C
 
-#if FATSHARK_HT_MODULE
-    digitalWrite(BUZZER, LOW);
-#endif
 
-    InitPWMInterrupt();         // Start PWM interrupt  
-    Wire.begin();               // Start I2C
+    byte vers=EEPROM.read(0); // first byte
 
     // If the device have just been programmed, write initial config/values to EEPROM:
-    if (EEPROM.read(0) != 8)
-    {
+    if ( vers != EEPROM_VERSION) {
 //#if (DEBUG)
-        Serial.println("New board - saving default values!");
+        Serial.printf_P(PSTR("New board (%d) - saving default values!\n"),vers);
 //#endif    
+	clearSettings();
     
         InitSensors();
-#if (ALWAYS_CAL_GYRO)    
-        SetGyroOffset();
-#endif     
-
-        SaveSettings();
-        SaveMagData();
-        SaveAccelData();
+        SaveSettings(); // all!
     }
  
     GetSettings();                 // Get settings saved in EEPROM
@@ -166,10 +120,91 @@ void setup()
     }
  
     GetSettings();                 // Get settings saved in EEPROM
+
     InitSensors();                // Initialize I2C sensors
+//#if ALWAYS_CAL_GYRO - uses delay() so should be before reinit Timer0
+    SetGyroOffset();
+//#endif     
+    CalibrateAccel();
     CalibrateMag();
+
     ResetCenter();
+//    resetValues=1;
+
+
+#if FATSHARK_HT_MODULE
+    pinMode(BUZZER,OUTPUT);         // Buzzer
+    digitalWrite(BUZZER, HIGH);
+    // Give it time to be noticed, then turn it off
+    delay(100); // Note: only use delay here. This won't work when Timer0 is repurposed later in InitTimerInterrupt
+    digitalWrite(BUZZER, LOW);
+#endif
+
+//
     InitTimerInterrupt();        // Start timer interrupt (for sensors)  
+    InitPWMInterrupt();         // Start PWM interrupt  
+
+    digitalWrite(ARDUINO_LED, LOW); //ready
+
+#if DEBUG
+//    DebugOutput(); - not works
+#endif
+
+    Serial.print_P(PSTR("$OK!$\n"));
+
+}
+
+int tail_cmp(const char *pat){
+    char *str=&serial_data[serial_index];
+    int len=strlen(pat);
+    return !strncmp(str-len,pat,len);
+}
+
+
+void parse_data(byte off, int *valuesReceived, byte n) {
+    byte comma_index = 0;
+    byte neg=0;
+
+#if DEBUG
+        int *ptr0=valuesReceived;
+#endif
+
+    for (byte k = 0; k < serial_index - off && comma_index < n; k++) {
+
+#if 0 && DEBUG
+        Serial.print(serial_data[k]);
+#endif
+
+        // Looking for comma
+        if (serial_data[k] == ',') {
+    	    if(neg){
+    		*valuesReceived = -*valuesReceived;
+    		neg=0;
+    	    }
+            comma_index++;
+            valuesReceived++;
+        } else if (serial_data[k] == '-') {
+    	    neg=1;
+        } else  {
+            *valuesReceived = *valuesReceived * 10 + (serial_data[k] - '0');
+        }
+    }
+
+
+    if(neg){ // the last one
+	*valuesReceived = -*valuesReceived;
+	neg=0;
+    }
+
+#if 0 && DEBUG
+                Serial.print("\n>");
+                for (byte k = 0; k < comma_index+1; k++) {
+                    Serial.print(ptr0[k]); 
+                    Serial.write(',');
+                }
+                Serial.println();
+#endif
+
 }
 
 //--------------------------------------------------------------------------------------
@@ -180,57 +215,57 @@ void loop()
 {  
     // Check input button for reset/pause request
     char buttonPressed = (digitalRead(BUTTON_INPUT) == 0);
+    byte c;
 
-    if ( buttonPressed && lastButtonState == 0)
-    {
+    if ( buttonPressed && lastButtonState == 0)  { // только нажали 
         resetValues = 1; 
         buttonDownTime = 0;
         lastButtonState = 1;
     }
     
-    if ( buttonPressed )
-    {
-        if ( !pauseToggled && (buttonDownTime > BUTTON_HOLD_PAUSE_THRESH) )
-        {
+    if ( buttonPressed ) {
+        if ( !pauseToggled && (buttonDownTime > BUTTON_HOLD_PAUSE_THRESH) )  {
             // Pause/unpause
             ht_paused = !ht_paused;
             resetValues = 1;
             pauseToggled = 1;
         }
-    }
-    else
-    {
+    }  else  {
         pauseToggled = 0;
         lastButtonState = 0;
     }
     
+    
+
+#if defined(ADC_PIN)
+   int val = analogRead(ADC_PIN);
+   
+   //0-1023 convert to 0.2..5
+   dynFactor = (val / 1023) * (5-0.2)  + 0.2;
+#endif
+  
+    
     // All this is used for communication with GUI 
     //
-    if (Serial.available())
-    {
-        if (string_started == 1)
-        {
+    if (Serial.available()>0)  {
+        if (string_started == 1)  {
             // Read incoming byte
             serial_data[serial_index++] = Serial.read();
-           
+#ifdef ECHO
+           Serial.write(serial_data[serial_index-1]);
+#endif
             // If string ends with "CH" it's channel configuration, that have been received.
             // String must always be 12 chars/bytes and ending with CH to be valid. 
-            if (serial_index == 14 &&
-                serial_data[serial_index-2] == 'C' &&
-                serial_data[serial_index-1] == 'H' )
-            {
-                // To keep it simple, we will not let the channels be 0-initialized, but
+            if (serial_index == 14 && tail_cmp("CH"))  {               // To keep it simple, we will not let the channels be 0-initialized, but
                 // start from 1 to match actual channels. 
                 for (unsigned char i = 0; i < 13; i++)  {
-                    channel_mapping[i + 1] = serial_data[i] - 48;
-                  
                     // Update the dedicated PPM-in -> PPM-out array for faster performance.
                     if ((serial_data[i] - 48) < 14) {
-                        PpmIn_PpmOut[serial_data[i]-48] = i + 1;
+                        sets.PpmIn_PpmOut[serial_data[i]-48] = i + 1;
                     }
                 }
                
-                Serial.println("Channel mapping received");
+                Serial.print_P(PSTR("Channel mapping received\n"));
                
                // Reset serial_index and serial_started
                serial_index = 0;
@@ -238,15 +273,13 @@ void loop()
             }
             
             // Configure headtracker
-            else if (serial_data[serial_index-2] == 'H' &&
-                     serial_data[serial_index-1] == 'E')
-            {
+            else if (tail_cmp("HE"))  {
                 // HT parameters are passed in from the PC in this order:
                 //
                 // 0 tiltRollBeta      
                 // 1 panBeta       
                 // 2 gyroWeightTiltRoll    
-                // 3 GyroWeightPan 
+                // 3 gyroWeightPan 
                 // 4 tiltFactor        
                 // 5 panFactor          
                 // 6 rollFactor
@@ -267,84 +300,53 @@ void loop()
                 // Parameters from the PC client need to be scaled to match our local
                 // expectations
 
-                Serial.println("HT config received:");
+                Serial.print_P(PSTR("HT config received: "));
            
                 int valuesReceived[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
-                int comma_index = 0;
 
-                for (unsigned char k = 0; k < serial_index - 2; k++)
-                {
-                    // Looking for comma
-                    if (serial_data[k] == 44)
-                    {
-                        comma_index++;
-                    }
-                    else
-                    {
-                        valuesReceived[comma_index] = valuesReceived[comma_index] * 10 + (serial_data[k] - 48);
-                    }
+		parse_data(2, valuesReceived, 20);
              
-#if (DEBUG)
-                    Serial.print(serial_data[k]);
-#endif
-                }
+                sets.tiltRollBeta  = (float)valuesReceived[0] / 100;  
+                sets.panBeta       = (float)valuesReceived[1] / 100;
+                sets.gyroWeightTiltRoll = (float)valuesReceived[2] / 100;
+                sets.gyroWeightPan = (float)valuesReceived[3] / 100;
+                sets.tiltFactor    = (float)valuesReceived[4] / 10;
+                sets.panFactor     = (float)valuesReceived[5] / 10;
+                sets.rollFactor    = (float)valuesReceived[6] / 10;
 
-#if (DEBUG)
-                Serial.println();
-                for (unsigned char k = 0; k < comma_index+1; k++)
-                {
-                    Serial.print(valuesReceived[k]); 
-                    Serial.print(",");           
-                }
-                Serial.println();
-#endif
+                sets.servoReverseMask = (unsigned char)valuesReceived[7];
 
-                tiltRollBeta  = (float)valuesReceived[0] / 100;  
-                panBeta       = (float)valuesReceived[1] / 100;
-                gyroWeightTiltRoll = (float)valuesReceived[2] / 100;
-                GyroWeightPan = (float)valuesReceived[3] / 100;
-                tiltFactor    = (float)valuesReceived[4] / 10;         
-                panFactor     = (float)valuesReceived[5] / 10;          
-                rollFactor    = (float)valuesReceived[6] / 10;   
-
-                servoReverseMask = (unsigned char)valuesReceived[7];
-
-                tiltInverse = 1;
-                rollInverse = 1;
-                panInverse = 1;           
+                if(sets.servoReverseMask & HT_PAN_REVERSE_BIT) 
+                    sets.panFactor *= -1;
                 
-                if ((servoReverseMask & HT_PAN_REVERSE_BIT) != 0)
-                {
-                    panInverse = -1;
-                }
-                if ((servoReverseMask & HT_ROLL_REVERSE_BIT) != 0)
-                {
-                    rollInverse = -1; 
-                }
-                if ((servoReverseMask & HT_TILT_REVERSE_BIT) != 0)
-                {
-                    tiltInverse = -1;
-                }
+                if(sets.servoReverseMask & HT_ROLL_REVERSE_BIT) 
+                    sets.rollFactor *= -1; 
 
-                servoPanCenter = valuesReceived[8];
-                panMinPulse = valuesReceived[9];
-                panMaxPulse = valuesReceived[10];         
+                if(sets.servoReverseMask & HT_TILT_REVERSE_BIT) 
+                    sets.tiltFactor *= -1;
          
-                servoTiltCenter = valuesReceived[11];
-                tiltMinPulse = valuesReceived[12];
-                tiltMaxPulse = valuesReceived[13];         
 
-                servoRollCenter = valuesReceived[14];
-                rollMinPulse = valuesReceived[15];
-                rollMaxPulse = valuesReceived[16];              
+                sets.servoPanCenter = valuesReceived[8];
+                sets.panMinPulse = valuesReceived[9];
+                sets.panMaxPulse = valuesReceived[10];
      
-                htChannels[0] = valuesReceived[17];                   
-                htChannels[1] = valuesReceived[18];              
-                htChannels[2] = valuesReceived[19];                       
+                sets.servoTiltCenter = valuesReceived[11];
+                sets.tiltMinPulse = valuesReceived[12];
+                sets.tiltMaxPulse = valuesReceived[13];
 
-                Serial.println(htChannels[0]);
-                Serial.println(htChannels[1]);
-                Serial.println(htChannels[2]);                
+                sets.servoRollCenter = valuesReceived[14];
+                sets.rollMinPulse = valuesReceived[15];
+                sets.rollMaxPulse = valuesReceived[16];
+     
+                sets.htChannels[0] = valuesReceived[17];
+                sets.htChannels[1] = valuesReceived[18];
+                sets.htChannels[2] = valuesReceived[19];
+
+#if 0 &&  (DEBUG)
+                Serial.println(sets.htChannels[0]);
+                Serial.println(sets.htChannels[1]);
+                Serial.println(sets.htChannels[2]);
+#endif
         
                 SaveSettings();
 
@@ -353,289 +355,265 @@ void loop()
             } // end configure headtracker
           
             // Debug info
-            else if (serial_data[serial_index-5] == 'D' &&
-                     serial_data[serial_index-4] == 'E' &&
-                     serial_data[serial_index-3] == 'B' &&
-                     serial_data[serial_index-2] == 'U' &&
-                     serial_data[serial_index-1] == 'G')
-            {  
+            else if (tail_cmp("DEBUG")) {
                 DebugOutput();
                 serial_index = 0;
                 string_started = 0; 
             }
 
             // Firmware version requested
-            else if (serial_data[serial_index-4] == 'V' &&
-                     serial_data[serial_index-3] == 'E' &&
-                     serial_data[serial_index-2] == 'R' &&
-                     serial_data[serial_index-1] == 'S')
-            {
-                Serial.print("FW: ");
-                Serial.println(FIRMWARE_VERSION_FLOAT, 2);
+            else if (tail_cmp("VERS")) {
+                Serial.printf_P(PSTR("FW: %S\n"), FIRMWARE_VERSION_FLOAT);
                 serial_index = 0;
                 string_started = 0; 
             }
           
             // Start mag and accel data stream
-            else if (serial_data[serial_index-4] == 'C' &&
-                     serial_data[serial_index-3] == 'M' &&
-                     serial_data[serial_index-2] == 'A' &&
-                     serial_data[serial_index-1] == 'S')
-            {  
+            else if (tail_cmp("CMAS"))  {  
+        	CalibrationStart();
                 outputMagAcc = 1;
-                outputMag = 0;
-                outputAcc = 0;
+//                outputMag = 0;
+//                outputAcc = 0;
                 outputTrack = 0;
                 serial_index = 0;
                 string_started = 0;
             }        
 
             // Stop mag and accel data stream
-            else if (serial_data[serial_index-4] == 'C' &&
-                     serial_data[serial_index-3] == 'M' &&
-                     serial_data[serial_index-2] == 'A' &&
-                     serial_data[serial_index-1] == 'E')
-            {  
+            else if (tail_cmp("CMAE")) {
                 outputMagAcc = 0;
-                outputMag = 0;
+//                outputMag = 0;
                 outputTrack = 0;
-                outputAcc = 0;
+//                outputAcc = 0;
                 serial_index = 0;
                 string_started = 0;
             }        
 
-            // Start magnetometer data stream
-            else if (serial_data[serial_index-4] == 'C' &&
-                     serial_data[serial_index-3] == 'A' &&
-                     serial_data[serial_index-2] == 'S' &&
-                     serial_data[serial_index-1] == 'T')
-            {  
-                outputMag = 1;
+            // Start tracking data stream
+            else if (tail_cmp("PLST")) {
+                outputTrack = 1;
                 outputMagAcc = 0;
-                outputAcc = 0;
-                outputTrack = 0;
+//                outputMag = 0;
+//                outputAcc = 0;
                 serial_index = 0;
                 string_started = 0; 
-
             }        
           
-            // Stop magnetometer data stream
-            else if (serial_data[serial_index-4] == 'C' &&
-                     serial_data[serial_index-3] == 'A' &&
-                     serial_data[serial_index-2] == 'E' &&
-                     serial_data[serial_index-1] == 'N')
-            {  
-                outputMag = 0;
-                outputMagAcc = 0;
-                outputAcc = 0;
+            // Stop tracking data stream
+            else if (tail_cmp("PLEN")) {
                 outputTrack = 0;
+//                outputMag = 0;
+//                outputAcc = 0;
+                outputMagAcc = 0;
                 serial_index = 0;
                 string_started = 0; 
             }
 
-            // Start accelerometer data stream
-            else if (serial_data[serial_index-4] == 'G' &&
-                     serial_data[serial_index-3] == 'R' &&
-                     serial_data[serial_index-2] == 'A' &&
-                     serial_data[serial_index-1] == 'V')
-            {  
-                outputAcc = 1;     
-                outputMagAcc = 0;
-                outputMag = 0;
-                outputTrack = 0;
+            // reset center - like button press
+            else if (tail_cmp("RESE")) {
+                resetValues=1;
                 serial_index = 0;
                 string_started = 0; 
+                Serial.print_P(PSTR("Center set!"));
             }              
           
-            // Stop accelerometer data stream
-            else if (serial_data[serial_index-4] == 'G' &&
-                     serial_data[serial_index-3] == 'R' &&
-                     serial_data[serial_index-2] == 'E' &&
-                     serial_data[serial_index-1] == 'N')
-            {  
-                outputAcc = 0;
-                outputMag = 0;
-                outputMagAcc = 0;
-                outputTrack = 0;
+            // Save RAM settings to EEPROM
+            else if (tail_cmp("SAVE")) {
+                SaveSettings();
                 serial_index = 0;
                 string_started = 0; 
             }
 
-            // Start tracking data stream
-            else if (serial_data[serial_index-4] == 'P' &&
-                     serial_data[serial_index-3] == 'L' &&
-                     serial_data[serial_index-2] == 'S' &&
-                     serial_data[serial_index-1] == 'T')
-            {  
-                outputTrack = 1;
-                outputMagAcc = 0;
-                outputMag = 0;
-                outputAcc = 0;
+          
+            // Calibrate gyro
+/*            else if (tail_cmp("CALG")) { 
+                //SetGyroOffset(); - uses delay() so should be before reinit Timer0
+//              SaveSettings();
+               
+		Serial.printf_P(PSTR("Gyro offset measured: %f,%f,%f\n"), sets.gyroOff[0], sets.gyroOff[1], sets.gyroOff[2]);
+
+                serial_index = 0;
+                string_started = 0; 
+            }
+*/
+#if DEBUG
+            else if (tail_cmp("DBG1"))  {  
+                outputDbg = 1;
                 serial_index = 0;
                 string_started = 0; 
             }        
 
-            // Stop tracking data stream          
-            else if (serial_data[serial_index-4] == 'P' &&
-                     serial_data[serial_index-3] == 'L' &&
-                     serial_data[serial_index-2] == 'E' &&
-                     serial_data[serial_index-1] == 'N')
-            {  
-                outputTrack = 0;
-                outputMag = 0;
-                outputAcc = 0;
-                outputMagAcc = 0;
+            else if (tail_cmp("DBG2"))  {  
+                outputDbg = 2;
                 serial_index = 0;
                 string_started = 0; 
             }
           
-            // Save RAM settings to EEPROM
-            else if (serial_data[serial_index-4] == 'S' &&
-                     serial_data[serial_index-3] == 'A' &&
-                     serial_data[serial_index-2] == 'V' &&
-                     serial_data[serial_index-1] == 'E')
-            {  
-                SaveSettings();     
+
+            else if (tail_cmp("DBG3")) {
+                outputDbg = 3;
                 serial_index = 0;
                 string_started = 0; 
             }          
           
-            // Calibrate gyro
-            else if (serial_data[serial_index-4] == 'C' &&
-                     serial_data[serial_index-3] == 'A' &&
-                     serial_data[serial_index-2] == 'L' &&
-                     serial_data[serial_index-1] == 'G')
-            { 
-                SetGyroOffset();
-                SaveSettings();
                
-                Serial.print("Gyro offset measured:");
-                Serial.print(gyroOff[0]);
-                Serial.print(",");   
-                Serial.print(gyroOff[1]);
-                Serial.print(",");      
-                Serial.println(gyroOff[2]);    
+            else if (tail_cmp("DBG4")) {
+                outputDbg = 4;
+                serial_index = 0;
+                string_started = 0; 
+            }        
                
+#if PPM_IN
+            else if (tail_cmp("DBGC")) {
+                outputDbg = 5;
                 serial_index = 0;
                 string_started = 0; 
             }
 
+#endif
+            // Stop debug data stream 
+            else if (tail_cmp("DBGE")) {  
+        	outputDbg=0;
+                serial_index = 0;
+                string_started = 0; 
+            }
+#endif
+
             // Store magnetometer offset
-            else if (serial_data[serial_index-3] == 'M' &&
-                     serial_data[serial_index-2] == 'A' &&
-                     serial_data[serial_index-1] == 'G')
-            {
+            else if (tail_cmp("MAG")) {
                 Serial.println(serial_data);
                 int valuesReceived[5] = {0,0,0,0,0};
-                int comma_index = 0; 
               
-                for (unsigned char k = 0; k < serial_index - 3; k++)
-                {
-                    // Looking for comma
-                    if (serial_data[k] == 44)
-                    {
-                        comma_index++;
-                    }
-                    else
-                    {
-                        valuesReceived[comma_index] = valuesReceived[comma_index] * 10 + (serial_data[k] - 48);
-                    }
+		parse_data(3, valuesReceived, 5);
+
+                // Y and Z are swapped on purpose - no more!.
+                sets.magOffset[0] = valuesReceived[0]/10.0;
+                sets.magOffset[1] = valuesReceived[1]/10.0;
+                sets.magOffset[2] = valuesReceived[2]/10.0;
+
+                serial_index = 0;
+                string_started = 0; 
+
+                //SaveMagData();                
+                WriteSets(offsetof(settings, magOffset ), sizeof(sets.magOffset));
+#if DEBUG
+		Serial.printf_P(PSTR("Mag offset stored %f,%f,%f\n"),  sets.magOffset[0], sets.magOffset[1], sets.magOffset[2]);
+#endif
                 }
                 
-                // Y and Z are swapped on purpose.
-                magOffset[0] = valuesReceived[0] - 2000;
-                magOffset[1] = valuesReceived[2] - 2000;
-                magOffset[2] = valuesReceived[1] - 2000;
+            // Store magnetometer gain
+            else if (tail_cmp("MGA")) {
+                Serial.println(serial_data);
+                int valuesReceived[5] = {0,0,0,0,0};
+
+		parse_data(3, valuesReceived, 5);
+
+                // Y and Z are swapped on purpose - no more!.
+                sets.magGain[0] = valuesReceived[0]/10000.0;
+                sets.magGain[1] = valuesReceived[1]/10000.0;
+                sets.magGain[2] = valuesReceived[2]/10000.0;
 
                 serial_index = 0;
                 string_started = 0; 
 
-                SaveMagData();                
+                //SaveMagGain();                
+                WriteSets(offsetof(settings, magGain ), sizeof(sets.magGain));
+#if DEBUG
+		Serial.printf_P(PSTR("Mag gain stored %f,%f,%f\n"),  sets.magGain[0], sets.magGain[1], sets.magGain[2]);
+#endif
             }
 
             // Store accelerometer offset
-            else if (serial_data[serial_index-3] == 'A' &&
-                     serial_data[serial_index-2] == 'C' &&
-                     serial_data[serial_index-1] == 'C')
-            {
+            else if (tail_cmp("ACC")) {
                 Serial.println(serial_data);
                 int valuesReceived[5] = {0,0,0,0,0};
-                int comma_index = 0; 
-                for (unsigned char k = 0; k < serial_index - 3; k++)
-                {
-                    // Looking for comma
-                    if (serial_data[k] == 44)
-                    {
-                        comma_index++;
-                    }
-                    else
-                    {
-                        valuesReceived[comma_index] = valuesReceived[comma_index] * 10 + (serial_data[k] - 48);
-                    }              
+
+		parse_data(3, valuesReceived, 5);
+
+                sets.accOffset[0] = valuesReceived[0]/10.0;
+                sets.accOffset[1] = valuesReceived[1]/10.0;
+                sets.accOffset[2] = valuesReceived[2]/10.0;
+
+                serial_index = 0;
+                string_started = 0; 
+
+                //SaveAccelData();
+                WriteSets(offsetof(settings, accOffset ), sizeof(sets.accOffset));
+#if DEBUG
+		Serial.printf_P(PSTR("Acc offset stored %f,%f,%f\n"),  sets.accOffset[0], sets.accOffset[1], sets.accOffset[2]);
+#endif
                 }
 
-                accOffset[0] = valuesReceived[0] - 2000;
-                accOffset[1] = valuesReceived[1] - 2000;
-                accOffset[2] = valuesReceived[2] - 2000;
+            // Store accelerometer gain
+            else if (tail_cmp("ACG")) {
+                Serial.println(serial_data);
+                int valuesReceived[5] = {0,0,0,0,0};
+
+		parse_data(3, valuesReceived, 5);
+
+                sets.accGain[0] = valuesReceived[0]/10000.0;
+                sets.accGain[1] = valuesReceived[1]/10000.0;
+                sets.accGain[2] = valuesReceived[2]/10000.0;
                 
                 serial_index = 0;
                 string_started = 0; 
 
-                SaveAccelData();                
+//                SaveAccelGain();
+                WriteSets(offsetof(settings, accGain ), sizeof(sets.accGain));
+#if DEBUG
+		Serial.printf_P(PSTR("Acc gain stored %f,%f,%f\n"),  sets.accGain[0], sets.accGain[1], sets.accGain[2]);
+#endif
             }
 
             // Retrieve settings
-            else if (serial_data[serial_index-4] == 'G' &&
-                     serial_data[serial_index-3] == 'S' &&
-                     serial_data[serial_index-2] == 'E' &&
-                     serial_data[serial_index-1] == 'T' )
-            {
+            else if (tail_cmp("GSET")) {
                 // Get Settings. Scale our local values to
                 // real-world values usable on the PC side.
                 //
-                Serial.print("$SET$"); // something recognizable in the stream
+                Serial.print_P(PSTR("$SET$")); // something recognizable in the stream
 
-                Serial.print(tiltRollBeta * 100);
-                Serial.print(",");   
-                Serial.print(panBeta * 100);
-                Serial.print(",");
-                Serial.print(gyroWeightTiltRoll * 100);  
-                Serial.print(",");
-                Serial.print(GyroWeightPan * 100);
-                Serial.print(",");
-                Serial.print(tiltFactor * 10);
-                Serial.print(",");
-                Serial.print(panFactor * 10);
-                Serial.print(",");
-                Serial.print(rollFactor * 10);
-                Serial.print(",");
-                Serial.print(servoReverseMask);
-                Serial.print(",");
-                Serial.print(servoPanCenter);
-                Serial.print(",");
-                Serial.print(panMinPulse);
-                Serial.print(",");
-                Serial.print(panMaxPulse);
-                Serial.print(",");
-                Serial.print(servoTiltCenter);
-                Serial.print(",");
-                Serial.print(tiltMinPulse);
-                Serial.print(",");
-                Serial.print(tiltMaxPulse);
-                Serial.print(",");
-                Serial.print(servoRollCenter);
-                Serial.print(",");
-                Serial.print(rollMinPulse);
-                Serial.print(",");
-                Serial.print(rollMaxPulse);
-                Serial.print(",");
-                Serial.print(htChannels[0]);
-                Serial.print(",");
-                Serial.print(htChannels[1]);
-                Serial.print(",");
-                Serial.println(htChannels[2]);
+		char c=',';
+                Serial.print(sets.tiltRollBeta * 100);
+                Serial.write(c);
+                Serial.print(sets.panBeta * 100);
+                Serial.write(c);
+                Serial.print(sets.gyroWeightTiltRoll * 100);  
+                Serial.write(c);
+                Serial.print(sets.gyroWeightPan * 100);
+                Serial.write(c);
+                Serial.print(sets.tiltFactor * 10);
+                Serial.write(c);
+                Serial.print(sets.panFactor * 10);
+                Serial.write(c);
+                Serial.print(sets.rollFactor * 10);
+                Serial.write(c);
+                Serial.print(sets.servoReverseMask);
+                Serial.write(c);
+                Serial.print(sets.servoPanCenter);
+                Serial.write(c);
+                Serial.print(sets.panMinPulse);
+                Serial.write(c);
+                Serial.print(sets.panMaxPulse);
+                Serial.write(c);
+                Serial.print(sets.servoTiltCenter);
+                Serial.write(c);
+                Serial.print(sets.tiltMinPulse);
+                Serial.write(c);
+                Serial.print(sets.tiltMaxPulse);
+                Serial.write(c);
+                Serial.print(sets.servoRollCenter);
+                Serial.write(c);
+                Serial.print(sets.rollMinPulse);
+                Serial.write(c);
+                Serial.print(sets.rollMaxPulse);
+                Serial.write(c);
+                Serial.print(sets.htChannels[0]);
+                Serial.write(c);
+                Serial.print(sets.htChannels[1]);
+                Serial.write(c);
+                Serial.println(sets.htChannels[2]);
 
-                Serial.println("Settings Retrieved!");
+//                Serial.printf_P(PSTR("Settings Retrieved!\n"));
 
                 serial_index = 0;
                 string_started = 0;
@@ -648,40 +626,44 @@ void loop()
                 string_started = 0;
             }
         }
-        else if (Serial.read() == '$')
+        else if ((c=Serial.read()) == '$')
         {
             string_started = 1;
+#ifdef ECHO
+            Serial.write('$');
+#endif
+        }else {
+#ifdef ECHO
+	    Serial.write(c);
+#endif
         }
     } // serial port input
 
     // if "read_sensors" flag is set high, read sensors and update
-    if (read_sensors == 1 && ht_paused == 0)
-    {
-        UpdateSensors();
+    if (read_sensors == 1 && ht_paused == 0) {
         GyroCalc();
         AccelCalc();
         MagCalc();
         FilterSensorData();    
                
         // Only output this data every X frames.
-        if (frameNumber++ >= SERIAL_OUTPUT_FRAME_INTERVAL)
-        {
-            if (outputTrack == 1)
-            {
-                trackerOutput();
-            }
-            else if (outputMagAcc == 1)
-            {
-                calMagAccOutput();
-            }
-            else if (outputMag == 1)
-            {
-                calMagOutput(); 
-            }
-            else if (outputAcc == 1)
-            {
-                calAccOutput();
-            }
+        if (frameNumber++ >= SERIAL_OUTPUT_FRAME_INTERVAL) {
+            if (outputTrack)            trackerOutput();
+            else if (outputMagAcc)      calMagAccOutput();
+//            else if (outputMag)         calMagOutput(); 
+//            else if (outputAcc)         calAccOutput();
+            
+#if DEBUG
+            if(outputDbg == 1)		testAccOutput();
+            if(outputDbg == 2)		testGyroOutput();
+            if(outputDbg == 3)		testMagOutput();
+            if(outputDbg == 4)		testAllData();
+ #if PPM_IN
+            if(outputDbg == 5)		testPPM_in();
+ #endif
+            outputDbg=0; // only once
+#endif
+            
             frameNumber = 0; 
         }
 
@@ -694,81 +676,14 @@ void loop()
 // Func: SaveSettings
 // Desc: Saves device settings to EEPROM for retrieval at boot-up.
 //--------------------------------------------------------------------------------------
-void SaveSettings()
-{  
-    EEPROM.write(1, (unsigned char)(tiltRollBeta * 100));
-    EEPROM.write(2, (unsigned char)(panBeta * 100));
-    EEPROM.write(3, (unsigned char)(gyroWeightTiltRoll * 100));
-    EEPROM.write(4, (unsigned char)(GyroWeightPan * 100));
-  
-    EEPROM.write(5, (unsigned char)servoReverseMask);
-    
-    // 6 unused
-  
-    EEPROM.write(7, (unsigned char)servoPanCenter);
-    EEPROM.write(8, (unsigned char)(servoPanCenter >> 8));  
-  
-    EEPROM.write(9, (unsigned char)(tiltFactor * 10));
-    EEPROM.write(10, (int)((tiltFactor * 10)) >> 8);  
-
-    EEPROM.write(11, (unsigned char) (panFactor * 10));
-    EEPROM.write(12, (int)((panFactor * 10)) >> 8);  
-
-    EEPROM.write(13, (unsigned char) (rollFactor * 10));
-    EEPROM.write(14, (int)((rollFactor * 10)) >> 8);  
-
-    // 15 unused
-
-    EEPROM.write(16, (unsigned char)servoTiltCenter);
-    EEPROM.write(17, (unsigned char)(servoTiltCenter >> 8));  
-
-    EEPROM.write(18, (unsigned char)servoRollCenter);
-    EEPROM.write(19, (unsigned char)(servoRollCenter >> 8));  
-
-
-    EEPROM.write(20, (unsigned char)panMaxPulse);
-    EEPROM.write(21, (unsigned char)(panMaxPulse >> 8));  
-  
-    EEPROM.write(22, (unsigned char)panMinPulse);
-    EEPROM.write(23, (unsigned char)(panMinPulse >> 8));    
-
-    EEPROM.write(24, (unsigned char)tiltMaxPulse);
-    EEPROM.write(25, (unsigned char)(tiltMaxPulse >> 8));    
 
-    EEPROM.write(26, (unsigned char)tiltMinPulse);
-    EEPROM.write(27, (unsigned char)(tiltMinPulse >> 8));
-
-    EEPROM.write(28, (unsigned char)rollMaxPulse);
-    EEPROM.write(29, (unsigned char)(rollMaxPulse >> 8));    
-
-    EEPROM.write(30, (unsigned char)rollMinPulse);
-    EEPROM.write(31, (unsigned char)(rollMinPulse >> 8)); 
-  
-    EEPROM.write(32, (unsigned char)htChannels[0]);
-    EEPROM.write(33, (unsigned char)htChannels[1]);
-    EEPROM.write(34, (unsigned char)htChannels[2]);
-  
-    // Saving gyro calibration values
-    int temp = (int)(gyroOff[0] + 500.5);
-    EEPROM.write(35, (unsigned char)temp);
-    EEPROM.write(36, (unsigned char)(temp >> 8));   
-  
-    temp = (int)(gyroOff[1] + 500.5);
-    EEPROM.write(37, (unsigned char)temp);
-    EEPROM.write(38, (unsigned char)(temp >> 8));     
-
-    temp = (int)(gyroOff[2] + 500.5);
-    EEPROM.write(39, (unsigned char)temp);
-    EEPROM.write(40, (unsigned char)(temp >> 8));    
-  
-    // Mark the memory to indicate that it has been
-    // written. Used to determine if board is newly flashed
-    // or not.
-    EEPROM.write(0,8); 
-
-    Serial.println("Settings saved!");
+inline void SaveSettings()
+{  
+    WriteSets();
+    Serial.print_P(PSTR("Settings saved!\n"));
 }
 
+
 //--------------------------------------------------------------------------------------
 // Func: GetSettings
 // Desc: Retrieves device settings from EEPROM.
@@ -773,190 +688,98 @@ void SaveSettings()
 // Func: GetSettings
 // Desc: Retrieves device settings from EEPROM.
 //--------------------------------------------------------------------------------------
-void GetSettings()
+inline void GetSettings()
 {  
-    tiltRollBeta    = (float)EEPROM.read(1) / 100;
-    panBeta         = (float)EEPROM.read(2) / 100;
-    gyroWeightTiltRoll = (float)EEPROM.read(3) / 100;
-    GyroWeightPan   = (float)EEPROM.read(4) / 100;  
-  
-    tiltInverse = 1;
-    rollInverse = 1;
-    panInverse = 1;
-
-    unsigned char temp = EEPROM.read(5);
-    if ( temp & HT_TILT_REVERSE_BIT )
-    {
-        tiltInverse = -1;
-    }  
-    if ( temp & HT_ROLL_REVERSE_BIT )
-    {
-        rollInverse = -1;
-    }
-    if ( temp & HT_PAN_REVERSE_BIT )
-    {
-        panInverse = -1;
-    }
-
-    // 6 unused
 
-    servoPanCenter  = EEPROM.read(7) + (EEPROM.read(8) << 8);
-    tiltFactor      = (float)(EEPROM.read(9) + (EEPROM.read(10) << 8)) / 10;
-    panFactor       = (float)(EEPROM.read(11) + (EEPROM.read(12) << 8)) / 10;
-    rollFactor       = (float)(EEPROM.read(13) + (EEPROM.read(14) << 8)) / 10;  
-
-    // 15 unused
+    ReadSets();
+}
 
-    servoTiltCenter = EEPROM.read(16) + (EEPROM.read(17) << 8);
-    servoRollCenter = EEPROM.read(18) + (EEPROM.read(19) << 8);  
   
-    panMaxPulse   = EEPROM.read(20) + (EEPROM.read(21) << 8);  
-    panMinPulse   = EEPROM.read(22) + (EEPROM.read(23) << 8);    
   
-    tiltMaxPulse  = EEPROM.read(24) + (EEPROM.read(25) << 8);  
-    tiltMinPulse  = EEPROM.read(26) + (EEPROM.read(27) << 8);      
+//--------------------------------------------------------------------------------------
+// Func: DebugOutput
+// Desc: Outputs useful device/debug information to the serial port.
+//--------------------------------------------------------------------------------------
+void DebugOutput()
+{
+    Serial.print_P(PSTR("\n\n\n------ Debug info------\n"));
   
-    rollMaxPulse  = EEPROM.read(28) + (EEPROM.read(29) << 8);  
-    rollMinPulse  = EEPROM.read(30) + (EEPROM.read(31) << 8);        
   
-    htChannels[0] = EEPROM.read(32);  
-    htChannels[1] = EEPROM.read(33);  
-    htChannels[2] = EEPROM.read(34);    
+    Serial.printf_P(PSTR("FW Version: %S"),FIRMWARE_VERSION_FLOAT);
   
-    gyroOff[0] = EEPROM.read(35) + (EEPROM.read(36) << 8) - 500; 
-    gyroOff[1] = EEPROM.read(37) + (EEPROM.read(38) << 8) - 500; 
-    gyroOff[2] = EEPROM.read(39) + (EEPROM.read(40) << 8) - 500;   
+    Serial.printf_P(PSTR("Mag type: %i\n"), compass);
   
-    magOffset[0] = EEPROM.read(200) + (EEPROM.read(201) << 8) - 2000;     
-    magOffset[1] = EEPROM.read(202) + (EEPROM.read(203) << 8) - 2000;     
-    magOffset[2] = EEPROM.read(204) + (EEPROM.read(205) << 8) - 2000;       
+/*    
+    Serial.printf_P(PSTR("tiltRollBeta: %f\n"),sets.tiltRollBeta);
+    Serial.printf_P(PSTR("panBeta: %f\n"),sets.panBeta);
   
-    accOffset[0] = EEPROM.read(206) + (EEPROM.read(207) << 8) - 2000;     
-    accOffset[1] = EEPROM.read(208) + (EEPROM.read(209) << 8) - 2000;     
-    accOffset[2] = EEPROM.read(210) + (EEPROM.read(211) << 8) - 2000;       
+    Serial.printf_P(PSTR("gyroWeightTiltRoll: %f\n"),sets.gyroWeightTiltRoll);
+    Serial.printf_P(PSTR("GyroWeightPan: %f\n"), sets.gyroWeightPan); 
+    Serial.printf_P(PSTR("servoPanCenter: %d\n"),sets.servoPanCenter); 
+    Serial.printf_P(PSTR("servoTiltCenter: %d\n"),sets.servoTiltCenter); 
+    Serial.printf_P(PSTR("servoRollCenter: %d\n"), sets.servoRollCenter); 
+
+    Serial.printf_P(PSTR("tiltFactor: %f\n"),sets.tiltFactor);
+    Serial.printf_P(PSTR("panFactor: %f\n"), sets.panFactor);
+    Serial.printf_P(PSTR("rollFactor: %f\n"), sets.rollFactor);
+*/
+    Serial.printf_P(PSTR("Gyro offset stored %f,%f,%f\n"), sets.gyroOff[0], sets.gyroOff[1], sets.gyroOff[2]);
   
+    Serial.printf_P(PSTR("Mag offset stored %f,%f,%f\n"),  sets.magOffset[0], sets.magOffset[1], sets.magOffset[2]);
+    Serial.printf_P(PSTR("Mag gain stored %f,%f,%f\n"),  sets.magGain[0], sets.magGain[1], sets.magGain[2]);
  
-#if (DEBUG)
-    DebugOutput();
+    Serial.printf_P(PSTR("Acc offset stored %f,%f,%f\n"),  sets.accOffset[0], sets.accOffset[1], sets.accOffset[2]);
+    Serial.printf_P(PSTR("Acc gain stored %f,%f,%f\n"),  sets.accGain[0], sets.accGain[1], sets.accGain[2]);
+#if PPM_IN
+    Serial.printf_P(PSTR("Input channels detected: %d\n"),  channelsDetected);
 #endif
+    SensorInfoPrint();
 }
 
-//--------------------------------------------------------------------------------------
-// Func: SaveMagData
-// Desc: Stores magnetometer calibration info to EEPROM.
-//--------------------------------------------------------------------------------------
-void SaveMagData()
-{
-    int temp = (int)(magOffset[0] + 2000);
-    EEPROM.write(200, (unsigned char)temp);
-    EEPROM.write(201, (unsigned char)(temp >> 8));   
-  
-    temp = (int)(magOffset[1] + 2000);
-    EEPROM.write(202, (unsigned char)temp);
-    EEPROM.write(203, (unsigned char)(temp >> 8));   
-  
-    temp = (int)(magOffset[2] + 2000);
-    EEPROM.write(204, (unsigned char)temp);
-    EEPROM.write(205, (unsigned char)(temp >> 8));   
-  
-    Serial.println("Mag offset saved!"); 
-    Serial.print(magOffset[0]);
-    Serial.print(", "); 
-    Serial.print(magOffset[1]);
-    Serial.print(", ");   
-    Serial.println(magOffset[2]); 
-}
 
-//--------------------------------------------------------------------------------------
-// Func: SaveAccelData
-// Desc: Stores accelerometer calibration data to EEPOM.
-//--------------------------------------------------------------------------------------
-void SaveAccelData()
-{
-    int temp = (int)(accOffset[0] + 2000);
-    EEPROM.write(206, (unsigned char)temp);
-    EEPROM.write(207, (unsigned char)(temp >> 8));   
-  
-    temp = (int)(accOffset[1] + 2000);
-    EEPROM.write(208, (unsigned char)temp);
-    EEPROM.write(209, (unsigned char)(temp >> 8));   
-  
-    temp = (int)(accOffset[2] + 2000);
-    EEPROM.write(210, (unsigned char)temp);
-    EEPROM.write(211, (unsigned char)(temp >> 8));   
-  
-    Serial.println("Acc offset saved!"); 
-    Serial.print(accOffset[0]);
-    Serial.print(","); 
-    Serial.print(accOffset[1]);
-    Serial.print(",");   
-    Serial.println(accOffset[2]);  
-}
 
-//--------------------------------------------------------------------------------------
-// Func: DebugOutput
-// Desc: Outputs useful device/debug information to the serial port.
-//--------------------------------------------------------------------------------------
-void DebugOutput()
-{
-    Serial.println();  
-    Serial.println();
-    Serial.println();
-    Serial.println("------ Debug info------");
 
-    Serial.print("FW Version: ");
-    Serial.println(FIRMWARE_VERSION_FLOAT, 2);
+void ReadSets(void){
+    uint8_t  i;
+    for(i=0; i<sizeof(settings); i++)
+	((byte *)&sets)[i] = EEPROM.read( i ); // EEPROM.read(EEPROM_offs(sets) + i );
+}
     
-    Serial.print("tiltRollBeta: ");
-    Serial.println(tiltRollBeta); 
 
-    Serial.print("panBeta: ");
-    Serial.println(panBeta); 
- 
-    Serial.print("gyroWeightTiltRoll: ");
-    Serial.println(gyroWeightTiltRoll); 
-
-    Serial.print("GyroWeightPan: ");
-    Serial.println(GyroWeightPan); 
-
-    Serial.print("servoPanCenter: ");
-    Serial.println(servoPanCenter); 
- 
-    Serial.print("servoTiltCenter: ");
-    Serial.println(servoTiltCenter); 
-
-    Serial.print("servoRollCenter: ");
-    Serial.println(servoRollCenter); 
-
-    Serial.print("tiltFactor: ");
-    Serial.println(tiltFactor); 
-
-    Serial.print("panFactor: ");
-    Serial.println(panFactor);  
- 
-    Serial.print("Gyro offset stored ");
-    Serial.print(gyroOff[0]);
-    Serial.print(",");   
-    Serial.print(gyroOff[1]);
-    Serial.print(",");      
-    Serial.println(gyroOff[2]);    
- 
-    Serial.print("Mag offset stored ");
-    Serial.print(magOffset[0]);
-    Serial.print(",");   
-    Serial.print(magOffset[1]);
-    Serial.print(",");      
-    Serial.println(magOffset[2]);
- 
-    Serial.print("Acc offset stored ");
-    Serial.print(accOffset[0]);
-    Serial.print(",");   
-    Serial.print(accOffset[1]);
-    Serial.print(",");      
-    Serial.println(accOffset[2]);
+void WriteSets(void){
+    ht_paused=1;
  
-    SensorInfoPrint();    
+    uint8_t i;
+//    noInterrupts();
+    for(i=0; i<sizeof(settings); i++) {
+#if 0 && DEBUG
+        Serial.print( i);
+        Serial.write(' ');
+        Serial.println(((byte *)&sets)[i]); 
+#endif
+	EEPROM.write( i, ((byte *)&sets)[i] ); // .write(EEPROM_offs(sets) + i,...
+    }
+//    interrupts();
+    ht_paused=0;
 }
 
+void WriteSets(uint8_t addr, uint8_t length){
+    ht_paused=1;
 
+#if 0 && DEBUG
+Serial.printf_P(PSTR("WriteSets addr=%d len=%d size=%d\n"), addr, length, sizeof(settings));
+#endif
+    uint8_t  i;
 
+//    noInterrupts();
+    for(i=0; (addr+i)<sizeof(settings) && i<length; i++) {
+	EEPROM.write( addr+i, ((byte *)&sets)[addr+i] ); // .write(EEPROM_offs(sets) + i,...
+#if 0 && DEBUG
+        Serial.print( addr+i);
+        Serial.write(' ');
+        Serial.println(((byte *)&sets)[addr+i]); 
+#endif
+    }
+//    interrupts();
+    ht_paused=0;
+}
diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/eeprom.c DIY_Headtracker_Firmware_fastserial/DIY_headtracker/eeprom.c
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/eeprom.c	2015-04-27 14:47:47.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/eeprom.c	1970-01-01 05:00:00.000000000 +0500
@@ -1,24 +0,0 @@
-#include "eeprom.h"
-
-#if 0
-
-void ReadSets(void){
-    for(int i=0; i<sizeof(Settings); i++)
-	((byte *)&sets)[i] = EEPROM.read( i ); // EEPROM.read(EEPROM_offs(sets) + i );
-}
-
-
-void WriteSets(void){
-    for(int i=0; i<sizeof(Settings); i++)
-	EEPROM.write( i, ((byte *)&sets)[i] ); // .write(EEPROM_offs(sets) + i,...
-}
-
-void WriteSets(int addr, int length){
-    for(int i=addr; i<sizeof(Settings) && i<length; i++)
-	EEPROM.write( i, ((byte *)&sets)[i] ); // .write(EEPROM_offs(sets) + i,...
-}
-
-
-
-
-#endif
diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/eeprom.h DIY_Headtracker_Firmware_fastserial/DIY_headtracker/eeprom.h
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/eeprom.h	2015-04-27 14:47:57.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/eeprom.h	2017-05-28 17:05:08.288156685 +0500
@@ -1,24 +1,14 @@
-#include <Arduino.h>
 
-struct Settings {
-    byte vers; // 8
-
-    float tiltRollBeta;
-    float panBeta;
-    float gyroWeightTiltRoll;
-    float gyroWeightPan;
-    byte servoReverseMask;
+#define EEPROM_VERSION 11
     
-    byte pad_6; // 6 unused
   
-    int iServoPanCenter;
-  
-    float tiltFactor;
-    float panFactor;
-    float rollFactor;
-
-    byte pad_15;// 15 unused
+#pragma pack(push,1)
+struct Settings {
+//0
+    byte vers; 
+    byte servoReverseMask;
 
+    int servoPanCenter;
     int servoTiltCenter;
     int servoRollCenter;
 
@@ -31,11 +21,34 @@ struct Settings {
     int rollMaxPulse;
     int rollMinPulse;
   
-    byte htChannels[3];
+    float tiltRollBeta;
+    float panBeta;
+    float gyroWeightTiltRoll;
+    float gyroWeightPan;
+  
+    float tiltFactor;
+    float panFactor;
+    float rollFactor;
   
-    // Saving gyro calibration values
-    float gyroOff[3]; // 35
     float magOffset[3];
+    float gyroOff[3];
     float accOffset[3];
+
+    byte htChannels[4];
+
+// NEW
+    byte PpmIn_PpmOut[16];
+
+    float magGain[3];
+    float accGain[3];
 };
 
+typedef struct Settings settings;
+
+#pragma pack(pop)
+
+extern settings sets;
+
+void ReadSets(void);
+void WriteSets(void);
+void WriteSets(uint8_t addr, uint8_t length);
diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/FourtOrderFilter.h DIY_Headtracker_Firmware_fastserial/DIY_headtracker/FourtOrderFilter.h
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/FourtOrderFilter.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/FourtOrderFilter.h	2015-07-23 13:42:37.104363170 +0500
@@ -0,0 +1,80 @@
+/*
+  AeroQuad v3.0.1 - February 2012
+  www.AeroQuad.com
+  Copyright (c) 2012 Ted Carancho.  All rights reserved.
+  An Open Source Arduino based multicopter.
+ 
+  This program is free software: you can redistribute it and/or modify 
+  it under the terms of the GNU General Public License as published by 
+  the Free Software Foundation, either version 3 of the License, or 
+  (at your option) any later version. 
+
+  This program is distributed in the hope that it will be useful, 
+  but WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
+  GNU General Public License for more details. 
+
+  You should have received a copy of the GNU General Public License 
+  along with this program. If not, see <http://www.gnu.org/licenses/>. 
+*/
+
+#ifndef _AQ_FOURTH_ORDER_FILTER_H_
+#define _AQ_FOURTH_ORDER_FILTER_H_
+
+////////////////////////////////////////////////////////////////////////////////
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+
+
+struct fourthOrderData
+{
+  float  inputTm1,  inputTm2,  inputTm3,  inputTm4;
+  float outputTm1, outputTm2, outputTm3, outputTm4;
+} fourthOrder[3] = {
+    {0,0,0,0, 0,0,0,0},	// X
+    {0,0,0,0, 0,0,0,0}, // Y
+    {-9.8065, -9.8065, -9.8065, -9.8065,  -9.8065, -9.8065, -9.8065, -9.8065 }, //Z
+};
+
+float computeFourthOrder(float currentInput, struct fourthOrderData *filterParameters)
+{
+  // cheby2(4,60,12.5/50)
+  #define _b0  0.001893594048567
+  #define _b1 -0.002220262954039
+  #define _b2  0.003389066536478
+  #define _b3 -0.002220262954039
+  #define _b4  0.001893594048567
+  
+  #define _a1 -3.362256889209355
+  #define _a2  4.282608240117919
+  #define _a3 -2.444765517272841
+  #define _a4  0.527149895089809
+  
+  float output;
+  
+  output = _b0 * currentInput                + 
+           _b1 * filterParameters->inputTm1  + 
+           _b2 * filterParameters->inputTm2  +
+           _b3 * filterParameters->inputTm3  +
+           _b4 * filterParameters->inputTm4  -
+           _a1 * filterParameters->outputTm1 -
+           _a2 * filterParameters->outputTm2 -
+           _a3 * filterParameters->outputTm3 -
+           _a4 * filterParameters->outputTm4;
+
+  filterParameters->inputTm4 = filterParameters->inputTm3;
+  filterParameters->inputTm3 = filterParameters->inputTm2;
+  filterParameters->inputTm2 = filterParameters->inputTm1;
+  filterParameters->inputTm1 = currentInput;
+  
+  filterParameters->outputTm4 = filterParameters->outputTm3;
+  filterParameters->outputTm3 = filterParameters->outputTm2;
+  filterParameters->outputTm2 = filterParameters->outputTm1;
+  filterParameters->outputTm1 = output;
+    
+  return output;
+}
+
+
+#endif
diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/Functions.cpp DIY_Headtracker_Firmware_fastserial/DIY_headtracker/Functions.cpp
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/Functions.cpp	2017-05-28 19:06:49.862465211 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/Functions.cpp	2017-05-28 16:57:47.454244902 +0500
@@ -2,6 +2,8 @@
 // File: Functions.cpp
 // Desc: Implementations of PPM-related functions for the project.
 //-----------------------------------------------------------------------------
+
+//#include <FastSerial.h>
 #include <SingleSerial.h>
 
 #include "config.h"
@@ -10,7 +12,6 @@
 #include "sensors.h"
 #include <Wire.h>
 
-extern long channel_value[];
 
 // Local variables
 unsigned int pulseTime = 0; 
@@ -18,50 +19,51 @@ unsigned int lastTime = 0;
 unsigned int timeRead; 
 int channelsDetected = 0;
 char channel = 0;
-int channelValues[20]; 
+
 char state = 0; // PPM signal high or Low?
 char read_sensors = 0;
 
 // external variables
 extern unsigned long buttonDownTime;
-extern unsigned char htChannels[];
 
 // Sensor_board,   x,y,z
-int acc_raw[3]  = {1,2,3};  
-int gyro_raw[3] = {4,5,6};
-int mag_raw[3]  = {7,8,9};
+int acc_raw[3];
+int gyro_raw[3];
+int mag_raw[3];
 
-unsigned char PpmIn_PpmOut[13] = {0,1,2,3,4,5,6,7,8,9,10,11,12};
-long channel_value[13] = {2100,2100,2100,2100,2100,2100,2100,2100,2100,2100,2100,2100,2100};
+// список коммутации каналов
+
+long channel_value[13] = {1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500};
+
+#if PPM_IN
+int channelValues[20];  // for input PPM
+#endif
 
 unsigned char channel_number = 1;
-char shift = 0;
-char time_out = 0;
+int8_t shift = 0;
+int8_t time_out = 0;
+
+extern byte ht_paused;
 
 //--------------------------------------------------------------------------------------
 // Func: PrintPPM
 // Desc: Prints the channel value represented in the stream. Debugging assistant. 
 //--------------------------------------------------------------------------------------
-void PrintPPM()
-{
-  for (byte j = 1; j < 13; j++)
-  {
+#if DEBUG
+void PrintPPM(){
+  for (byte j = 1; j < 13; j++)  {
       Serial.print(channel_value[j]);
-      Serial.print(",");
+      Serial.write(',');
   }
   Serial.println();
-  
 }
+#endif
 
 //--------------------------------------------------------------------------------------
 // Func: InitPWMInterrupt
 // Desc: 
 //--------------------------------------------------------------------------------------
-void InitPWMInterrupt()
-{
-#if (DEBUG)    
-    Serial.println("PWM interrupt initialized");
-#endif
+void InitPWMInterrupt(){
   
     TCCR1A = 
        (0 << WGM10) |
@@ -94,17 +96,23 @@ void InitPWMInterrupt()
 
     // OCR1A is used to generate PPM signal and later reset counter (to control frame-length)
     OCR1A = DEAD_TIME;    
+
+
+#if (DEBUG)    
+    Serial.print_P(PSTR("PWM interrupt initialized\n"));
+#endif
 }
 
 //--------------------------------------------------------------------------------------
 // Func: InitTimerInterrupt
 // Desc: Initializes timer interrupts.
 //--------------------------------------------------------------------------------------
+
+#define PRESCALE0 1024
+#define TIMER_CLOCK_FREQ0 16000000.0/PRESCALE0 // 16MHz
+
 void InitTimerInterrupt()
 {  
-#if (DEBUG)    
-    Serial.println("Timer interrupt initialized");
-#endif
   
     TCCR0A = 
        (0 << WGM00) |
@@ -128,10 +136,81 @@ void InitTimerInterrupt()
         (1 << OCIE0A) |
         (1 << TOIE0);       
 
-    OCR0B = 64 * 2; 
-    OCR0A = 64 * 2;
+    int cnt= ((TIMER_CLOCK_FREQ0/SAMPLERATE)+0.5);
+    if(cnt>255) cnt=255;
+
+//    OCR0B = 64 * 2;.
+//    OCR0A = 64 * 2;
+    OCR0B = (byte)cnt;
+    OCR0A = (byte)cnt;
+    
+//    OCR0B = 64 * 2; 
+//    OCR0A = 64 * 2;
+
+#if (DEBUG)    
+    Serial.printf_P(PSTR("Timer interrupt initialized: %d\n"),cnt);
+#endif
 }
 
+
+#define PRESCALE 8
+#define TIMER_CLOCK_FREQ 16000000.0/PRESCALE // 16MHz
+    //Установка Таймера2.
+    //Конфигурирует 8-битный Таймер2 ATMega168 для выработки прерывания
+    //с заданной частотой.
+    //Возвращает начальное значение таймера, которое должно быть загружено в TCNT2
+    //внутри вашей процедуры ISR.
+    //Смотри пример использования ниже.
+
+byte  SetupTimer2(float timeoutFrequency){
+    unsigned char result; //Начальное значение таймера.
+ 
+    //Подсчет начального значения таймера
+    result=(int)((256.0-(TIMER_CLOCK_FREQ/timeoutFrequency))+0.5);
+    //257 на самом деле должно быть 256, но я получил лучшие результаты с 257.
+ 
+    //Установки Таймер2: Делитель частоты /8, режим 0
+    //Частота = 16MHz/8 = 2Mhz или 0.5 мкс
+    //Делитель /8 дает нам хороший рабочий диапазон
+    //так что сейчас мы просто жестко запрограммируем это.
+    
+    TCCR2A = 0;
+    TCCR2B = 0<<CS22 | 1<<CS21 | 0<<CS20;
+ 
+    //Подключение прерывания по переполнению Timer2
+    TIMSK2 = 1<<TOIE2;
+ 
+    //загружает таймер для первого цикла
+    TCNT2=256 - result + 1;
+ 
+    return result;
+}
+
+//--------------------------------------------------------------------------------------
+// Func: TIMER0_COMPA_vect
+// Desc: Timer 0 compare A vector Sensor-interrupt. We query sensors on a timer, not
+//          during every loop.
+//--------------------------------------------------------------------------------------
+ISR(TIMER0_COMPA_vect){
+    // Reset counter - should be changed to CTC timer mode. 
+    TCNT0 = 0;
+
+
+    if (!ht_paused && read_sensors == 1) {
+        time_out++;
+        if (time_out > 10) {
+#if DEBUG
+        Serial.println("Timing problem!!!"); 
+#endif
+            time_out = 0;  
+            digitalWrite(ARDUINO_LED, HIGH);
+        }
+    }
+    read_sensors = 1;
+    buttonDownTime += 16; // every 16 milliseconds, at 61 hz.
+}
+
+#if DEBUG
 //--------------------------------------------------------------------------------------
 // Func: TIMER1_OVF_vect
 // Desc: Timer 1 overflow vector - only here for debugging/testing, as it should always
@@ -139,17 +218,65 @@ void InitTimerInterrupt()
 //--------------------------------------------------------------------------------------
 ISR(TIMER1_OVF_vect)
 {
-    Serial.print("Timer 1 OVF");
+    Serial.print_P(PSTR("Timer 1 OVF\n"));
 }
 
+#endif
+
 //--------------------------------------------------------------------------------------
 // Func: TIMER1_COMPA_vect
 // Desc: Timer 1 compare A vector
 //--------------------------------------------------------------------------------------
 ISR(TIMER1_COMPA_vect)
 {
-    if (OCR1A == FRAME_LENGTH)
-    {
+
+#if 1
+  static boolean state = true;
+  
+  TCNT1 = 0;
+  
+  if(state) {  //start pulse
+     TCCR1A = 
+            (0 << WGM10) |
+            (0 << WGM11) |
+            (0 << COM1A1) |
+            (POSITIVE_SHIFT_PPM << COM1A0) |
+            (0 << COM1B1) |
+            (0 << COM1B0); 
+ 
+    
+    OCR1A = DEAD_TIME;
+    state = false;
+  }
+  else{  //end pulse and calculate when to start the next pulse
+    static byte cur_chan_numb=0;
+    static unsigned int calc_rest=0;
+   
+            TCCR1A = 
+            (0 << WGM10) |
+            (0 << WGM11) |
+            (1 << COM1A1) |
+            (1 << COM1A0) |
+            (0 << COM1B1) |
+            (0 << COM1B0);  
+    
+    state = true;
+
+    if(cur_chan_numb >= NUMBER_OF_CHANNELS){
+      cur_chan_numb = 1;
+      calc_rest += DEAD_TIME;// 
+      OCR1A = (FRAME_LENGTH - calc_rest);
+      calc_rest = 0;
+    } else{
+      OCR1A = (channel_value[cur_chan_numb] - DEAD_TIME);
+      calc_rest += channel_value[cur_chan_numb];
+      cur_chan_numb++;
+    }     
+  }
+
+ 
+#else
+    if (OCR1A == FRAME_LENGTH) {
         TCCR1A = 
             (0 << WGM10) |
             (0 << WGM11) |
@@ -162,11 +289,8 @@ ISR(TIMER1_COMPA_vect)
         OCR1A = DEAD_TIME;
   
         TCCR1B &= ~(1 << WGM12);
-    }
-    else
-    {
-        if (channel_number == 1)
-        {
+    }   else {
+        if (channel_number == 1)  {
             // After first time, when pin have been set high, we toggle the pin at each interrupt
             TCCR1A = 
                 (0 << WGM10) |
@@ -177,107 +301,66 @@ ISR(TIMER1_COMPA_vect)
                 (0 << COM1B0);   
         }
                   
-        if ((channel_number - 1) < NUMBER_OF_CHANNELS * 2)
-        {
-            if ((channel_number-1) % 2 == 1)
-            {
+        if ((channel_number - 1) < NUMBER_OF_CHANNELS * 2) {
+            if ((channel_number-1) % 2 == 1) {
                 OCR1A += DEAD_TIME; 
-            }
-            else
-            {
+            } else {
                 OCR1A += channel_value[(channel_number + 1) / 2];
             }
             channel_number++;
-        }
-        else
-        {
+        } else {
             // We have to use OCR1A as top too, as ICR1 is used for input capture and OCR1B can't be
             // used as top. 
             OCR1A = FRAME_LENGTH;
             TCCR1B |= (1 << WGM12);
         }
     }
+#endif
 }  
 
-//--------------------------------------------------------------------------------------
-// Func: TIMER0_COMPA_vect
-// Desc: Timer 0 compare A vector Sensor-interrupt. We query sensors on a timer, not
-//          during every loop.
-//--------------------------------------------------------------------------------------
-ISR(TIMER0_COMPA_vect)
-{
-    // Reset counter - should be changed to CTC timer mode. 
-    TCNT0 = 0;
 
-/*
-    // Used to check timing - have the previous calculations been done?
-    // Will always show in start, but should stop when initialized. 
-    if (shift == 1)
-    {
-        //digitalWrite(7,HIGH); 
-        shift = 0;
-    }
-    else
-    {
-        //digitalWrite(7,LOW);
-        shift = 1; 
-    }
- */
-
-#if (DEBUG == 1)  
-    if (read_sensors == 1)
-    {
-        time_out++;
-        if (time_out > 10)
-        {
-            //Serial.println("Timing problem!!!"); 
-            time_out = 0;  
-        }
-    }
-#endif
-    read_sensors = 1;
-    buttonDownTime += 16; // every 16 milliseconds, at 61 hz.
-}
+#if PPM_IN
 
 //--------------------------------------------------------------------------------------
 // Func: DetectPPM
 // Desc: 
 //--------------------------------------------------------------------------------------
-void DetectPPM()
-{  
+void DetectPPM(){  
     // If a new frame is detected
-    if (pulseTime > 5500)
-    {
+    if (pulseTime > 5500) {
         // Save total channels detected
         channelsDetected = channel; 
      
         // Reset channel-count
         channel = 0; 
-    }
-    else if (channel < 20 && pulseTime > PPM_IN_MIN && pulseTime < PPM_IN_MAX)
-    {
+    }  else if (channel < 20 && pulseTime > PPM_IN_MIN && pulseTime < PPM_IN_MAX) {
         // If the pulse is recognized as servo-pulse
-        if ( (channel + 1) != htChannels[0] &&
-             (channel + 1) != htChannels[1] &&
-             (channel + 1) != htChannels[2] )
-        {
-            channelValues[channel++] = pulseTime;
-            channel_value[PpmIn_PpmOut[channel]] = pulseTime;
+        if ( (channel + 1) != sets.htChannels[0] &&
+             (channel + 1) != sets.htChannels[1] &&
+             (channel + 1) != sets.htChannels[2] )  {
+            channelValues[channel++] = pulseTime; // input data
+            channel_value[sets.PpmIn_PpmOut[channel]] = pulseTime; // for output
         }
-    }  
-    else if (pulseTime > PPM_IN_MIN)
-    {
+    } else if (pulseTime > PPM_IN_MIN) {
         channel++;
     }
 }  
 
+void testPPM_in(){
+    Serial.print_P(PSTR("Ch: "));
+    for(byte i=0; i<channelsDetected;i++){
+	Serial.printf_P(PSTR("%d "),channelValues[i]);
+    }
+    Serial.write(10);
+
+}
+
 //--------------------------------------------------------------------------------------
 // Func: TIMER1_CAPT_vect
 // Desc: The interrupt vector used when an edge is detected Interrupt vector, see page
 //      57 Interrupt for input capture
 //--------------------------------------------------------------------------------------
-ISR(TIMER1_CAPT_vect)
-{
+ISR(TIMER1_CAPT_vect) {
     // Disable interrupt first, to avoid multiple interrupts causing hanging/restart,
     // or just weird behavior:
     TIMSK1 &= ~(1 << ICIE1);
@@ -293,12 +376,9 @@ ISR(TIMER1_CAPT_vect)
     pulseTime = timeRead; 
     
     // Check if the timer have reached top/started over:
-    if (lastTime > pulseTime)
-    {
+    if (lastTime > pulseTime){
         pulseTime += (TOP - lastTime); 
-    }
-    else
-    {
+    } else {
         // Subtract last time to get the time:
         pulseTime -= lastTime;
     }
@@ -313,3 +393,5 @@ ISR(TIMER1_CAPT_vect)
     TIMSK1 |= (1 << ICIE1); 
 }
 
+#endif
+
diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/functions.h DIY_Headtracker_Firmware_fastserial/DIY_headtracker/functions.h
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/functions.h	2015-07-10 15:09:49.926349213 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/functions.h	2015-08-06 12:42:04.296699373 +0500
@@ -10,5 +10,7 @@ void InitPWMInterrupt();
 void DetectPPM();
 void PrintPPM();
 void DetectPPM();
+void testPPM_in();
 
+extern int channelsDetected;
 #endif
diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/Sensors.cpp DIY_Headtracker_Firmware_fastserial/DIY_headtracker/Sensors.cpp
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/Sensors.cpp	2017-05-28 19:07:45.196599678 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/Sensors.cpp	2017-05-28 17:01:44.057734272 +0500
@@ -1,13 +1,16 @@
-//-----------------------------------------------------------------------------
 // File: Sensors.cpp
 // Desc: Implementations sensor board functionality.
 //-----------------------------------------------------------------------------
+//#include <FastSerial.h>
 #include <SingleSerial.h>
 
 #include "config.h"
 #include "Arduino.h"
 #include "functions.h"
 #include <Wire.h>
+#include "sensors.h"
+
+#include "FourtOrderFilter.h"
 
 /*
 Reference for basic sensor/IMU understanding/calculation:
@@ -22,14 +25,13 @@ http://www.pololu.com/file/download/LSM3
 //
 #define ITG3205_ADDR 0x68    // The address of ITG3205
 #define ITG3205_X_ADDR 0x1D  // Start address for x-axis
-#define SCALING_FACTOR 13     // Scaling factor - used when converting to angle
+#define SCALING_FACTOR 15.1     // Scaling factor - used when converting to angle
 
 // Accelerometer
 //
 #define ADXL345_ADDR (0x53)  // The adress of ADXL345 
 #define ADXL345_X_ADDR (0x32)// Start address for x-axis
 #define ACC_SENS 256         // Sensitivity. 13 bit adc, +/- 16 g. Calculated as: (2^13)/(16*2)
-#define ASSUME_1G_ACC 0      // Assuming the total gravitation is 1. True if only earth gravitation has influence.  
 
 
 // Magnetometer
@@ -37,7 +39,40 @@ http://www.pololu.com/file/download/LSM3
 #define HMC_ADDR 0x1E        // The address of HMC5883
 #define HMC_X_ADDR (0x03)    // Start address for x-axis. 
 
-#define SAMPLERATE 128       // Samplerate of sensors (in hz, samples per second)
+#define TO_GRADUS  180/3.14159265
+#define FROM_GRADUS  1/TO_GRADUS
+
+#define ConfigRegA           0x00
+#define ConfigRegB           0x01
+#define MagGain              0x20
+#define PositiveBiasConfig   0x11
+#define NegativeBiasConfig   0x12
+#define NormalOperation      0x10
+
+#define ModeRegister         0x02
+#define ContinuousConversion 0x00
+#define SingleConversion     0x01
+
+// ConfigRegA valid sample averaging for 5883L
+#define SampleAveraging_1    0x00
+#define SampleAveraging_2    0x01
+#define SampleAveraging_4    0x02
+#define SampleAveraging_8    0x03
+
+// ConfigRegA valid data output rates for 5883L
+#define DataOutputRate_0_75HZ 0x00
+#define DataOutputRate_1_5HZ  0x01
+#define DataOutputRate_3HZ    0x02
+#define DataOutputRate_7_5HZ  0x03
+#define DataOutputRate_15HZ   0x04
+#define DataOutputRate_30HZ   0x05
+#define DataOutputRate_75HZ   0x06
+
+#define AP_COMPASS_TYPE_HMC5843         0x02
+#define AP_COMPASS_TYPE_HMC5883L        0x03
+
+byte compass;
+byte compass_mode=0;
 
 unsigned char ADXL345_ID = 0;
 unsigned char ITG3205_ID = 0;
@@ -49,34 +84,36 @@ extern long channel_value[];
 
 // Local variables
 //
-byte sensorBuffer[10];       // Buffer for bytes read from sensors
+union {
+    byte sensorBuffer[10];       // Buffer for bytes read from sensors
+    int inp[5];
+} sb;
+
 char resetValues = 1;        // Used to reset headtracker/re-center. 
 
-long accRaw[3];              // Raw readings from accelerometer
+int   accRaw[3];             // Raw readings from accelerometer
 float accG[3];               // G-force in each direction
 float accAngle[3];           // Measured angle from accelerometer
 float R;                     // Unit vector - total G.
 
-float gyroRaw[3];            // Raw readings from gyro
-float angle[3];              // Angle from gyro 
+int   gyroRaw[3];            // Raw readings from gyro
+float gyroAngle[3];          // Angle from gyro 
+#if DEBUG
 float angleRaw[3];           // Temp for angle-calculation
+#endif
+float gyro[3];
 
-float magRaw[3];             // Raw readings from magnetometer
+int   magRaw[3];             // Raw readings from magnetometer
+float magV[3];               // Normalized readings from magnetometer
+float MR=1;                  // magnet field normalization, 1 before calibration
+float mx=0, my=0, mz=0;      // Calculated magnetometer values in all directions with pan/tilt compensation
 float magAngle[3];           // Measured angles from magnetometer
-float mx = 0;                // Calculated magnetometer value in x-direction with pan/tilt compensation
-float my = 0;                // Calculated magnetometer value in y-direction with pan/tilt compensation
 
-int magPosOff[3];
-int magNegOff[3];
-float magGain[3];
-
-#define MAG0MAX 625
-#define MAG1MAX 625
-#define MAG2MAX 625
-#define MAG0MIN -625
-#define MAG1MIN -625
-#define MAG2MIN -625
 
+float magPosOff[3]; // калибровочные данные магнетометра
+float magNegOff[3];
+float magGain[3];
+float magMGain[3]={0,0,0}; // калибровочная нормировка по осям 
 
 // Final angles for headtracker:
 float tiltAngle = 90;       // Tilt angle
@@ -96,29 +133,26 @@ float tiltStart = 0;
 float panStart = 0;
 float rollStart = 0;
 
-char TrackerStarted = 0;
-
-// Servo reversing
-char tiltInverse = -1;
-char rollInverse = -1;
-char panInverse = -1;
-
+byte TrackerStarted = 0;
 
 // Settings
 //
+settings sets;
+/*
 float tiltRollBeta = 0.75;
 float panBeta = 0.75;
 float gyroWeightTiltRoll = 0.98;
-float GyroWeightPan = 0.98;
-int servoPanCenter = 2100;
-int servoTiltCenter = 2100;
-int servoRollCenter = 2100;
-int panMaxPulse = 1150;
-int panMinPulse = 1150;
-int tiltMaxPulse = 1150;
-int tiltMinPulse = 1150;
-int rollMaxPulse = 1150;
-int rollMinPulse = 1150;
+float gyroWeightPan = 0.98;
+
+int servoPanCenter = 1500;
+int servoTiltCenter = 1500;
+int servoRollCenter = 1500;
+int panMaxPulse = 2000;
+int panMinPulse = 1000;
+int tiltMaxPulse = 2000;
+int tiltMinPulse = 1000;
+int rollMaxPulse = 2000;
+int rollMinPulse = 1000;
 float panFactor = 17;
 float tiltFactor = 17;
 float rollFactor = 17;
@@ -123,17 +157,28 @@ float panFactor = 17;
 float tiltFactor = 17;
 float rollFactor = 17;
 unsigned char servoReverseMask = 0;
+
 int accOffset[3] = {0, 0, 0}; 
-float magOffset[3] = {(MAG0MAX + MAG0MIN) / 2, (MAG1MAX + MAG1MIN) / 2, (MAG2MAX + MAG2MIN) / 2};
+float magOffset[3] = {0, 0, 0};
 float gyroOff[3] = {0, 0, 0};
+
+
+
 unsigned char htChannels[3] = {8, 7, 6}; // pan, tilt, roll
+*/
+
+// дабы не считать дважды
+float sin_tilt, cos_tilt, sin_roll, cos_roll;
+
+extern float dynFactor;
+
+
 //
 // End settings
 
 
 // Function used to write to I2C:
-void WriteToI2C(int device, byte address, byte val)
-{
+void WriteToI2C(byte device, byte address, byte val){
     Wire.beginTransmission(device);
     Wire.write(address);
     Wire.write(val);
@@ -141,8 +186,7 @@ void WriteToI2C(int device, byte address
 }
 
 // Function to read from I2C
-void ReadFromI2C(int device, char address, char bytesToRead)
-{
+void ReadFromI2C(byte device, byte address, byte bytesToRead){
     Wire.beginTransmission(device);
     Wire.write(address);
     Wire.endTransmission();
@@ -150,83 +194,84 @@ void ReadFromI2C(int device, char addres
     Wire.beginTransmission(device);
     Wire.requestFrom(device, bytesToRead);
    
-    char i = 0;   
-    while ( Wire.available() )
-    {
-        sensorBuffer[i++] = Wire.read();
+    uint8_t i = 0;   
+    while ( Wire.available() ) {
+        sb.sensorBuffer[i++] = Wire.read();
     }   
     Wire.endTransmission();
 }
 
 void trackerOutput()
 {
-  Serial.print(tiltAngleLP - tiltStart + 90);
-  Serial.print(",");
-  Serial.print(rollAngleLP - rollStart + 90);
-  Serial.print(",");  
-  Serial.println(panAngleLP + 180);
+  Serial.print(tiltAngleLP - tiltStart );
+  Serial.write(',');
+  Serial.print(rollAngleLP - rollStart );
+  Serial.write(',');  
+  Serial.println(panAngleLP );
 }
-
+/*
 void calMagOutput()
 {
-    Serial.print((int)magRaw[0] + 3000);
-    Serial.print(",");
-    Serial.print((int)magRaw[1] + 3000);
-    Serial.print(",");    
-    Serial.println((int)magRaw[2] + 3000);   
+    Serial.printf_P(PSTR("%d,%d,%d\n"), magRaw[0], magRaw[1], magRaw[2]);
 }
 
 void calAccOutput()
 {
-    Serial.print((int)accRaw[0] + 3000);  
-    Serial.print(",");          
-    Serial.print((int)accRaw[1] + 3000);  
-    Serial.print(",");              
-    Serial.println((int)accRaw[2] + 3000);  
+    Serial.printf_P(PSTR("%d,%d,%d\n"), accRaw[0], accRaw[1], accRaw[2]);
 }
+*/
+
 
+// for calibration
 void calMagAccOutput()
 {
-    Serial.print((int)magRaw[0] + 3000);
-    Serial.print(",");
-    Serial.print((int)magRaw[1] + 3000);
-    Serial.print(",");    
-    Serial.print((int)magRaw[2] + 3000);
-    Serial.print(","); 
-    Serial.print((int)accRaw[0] + 3000);  
-    Serial.print(",");          
-    Serial.print((int)accRaw[1] + 3000);  
-    Serial.print(",");              
-    Serial.println((int)accRaw[2] + 3000); 
+    Serial.printf_P(PSTR("%d,%d,%d,%d,%d,%d\n"),  magRaw[0], magRaw[1], magRaw[2], accRaw[0], accRaw[1], accRaw[2]);
 }
 
-//--------------------------------------------------------------------------------------
-// Func: UpdateSensors
-// Desc: Retrieves the sensor data from the sensor board via I2C.
-//--------------------------------------------------------------------------------------
-void UpdateSensors()
-{
 
+
+void readCompassRaw(void){    // Read x, y, z from magnetometer;
+    ReadFromI2C(HMC_ADDR, HMC_X_ADDR, 6);
+
+    magRaw[0] =     sb.sensorBuffer[1] | ((uint16_t)sb.sensorBuffer[0] << 8);
+
+//    if (compass == AP_COMPASS_TYPE_HMC5883L) {
+//        magRaw[1] = sb.sensorBuffer[3] | ((int)sb.sensorBuffer[2] << 8);
+//        magRaw[2] = sb.sensorBuffer[5] | ((int)sb.sensorBuffer[4] << 8);
+//    } else {
+        magRaw[2] = sb.sensorBuffer[3] | ((uint16_t)sb.sensorBuffer[2] << 8);
+        magRaw[1] = sb.sensorBuffer[5] | ((uint16_t)sb.sensorBuffer[4] << 8);
+//    }
+
+
+}
+
+
+void readAccelRaw(){
     // Read x, y, z acceleration, pack the data.
     ReadFromI2C(ADXL345_ADDR, ADXL345_X_ADDR, 6);
-    accRaw[0] = ((int)sensorBuffer[0] | ((int)sensorBuffer[1] << 8)) * -1;
-    accRaw[1] = ((int)sensorBuffer[2] | ((int)sensorBuffer[3] << 8)) * -1;       
-    accRaw[2] = (int)sensorBuffer[4] | ((int)sensorBuffer[5] << 8);       
    
+    accRaw[0] = -sb.inp[0]; // ((int)sensorBuffer[0] | ((int)sensorBuffer[1] << 8)) * -1;
+    accRaw[1] = -sb.inp[1]; // ((int)sensorBuffer[2] | ((int)sensorBuffer[3] << 8)) * -1;
+    accRaw[2] =  sb.inp[2]; //  (int)sensorBuffer[4] | ((int)sensorBuffer[5] << 8);
+}
    
+void readGyroRaw(){
     // Read x, y, z from gyro, pack the data
     ReadFromI2C(ITG3205_ADDR, ITG3205_X_ADDR, 6);
-    gyroRaw[0] = (int)sensorBuffer[1] | ((int)sensorBuffer[0] << 8);
-    gyroRaw[1] = ( (int)sensorBuffer[3] | ((int)sensorBuffer[2] << 8) ) * -1;
-    gyroRaw[2] = ( (int)sensorBuffer[5] | ((int)sensorBuffer[4] << 8) ) * -1;
    
+    gyroRaw[0] =  ((int)sb.sensorBuffer[1] | ((int)sb.sensorBuffer[0] << 8) ) * -1;		// BIG-ENDIAN :(
+    gyroRaw[1] =  ((int)sb.sensorBuffer[3] | ((int)sb.sensorBuffer[2] << 8) ) * -1;
+    gyroRaw[2] =  ((int)sb.sensorBuffer[5] | ((int)sb.sensorBuffer[4] << 8) ) *  1;
    
-    // Read x, y, z from magnetometer;
-    ReadFromI2C(HMC_ADDR, HMC_X_ADDR, 6);
-    for (unsigned char i =0; i < 3; i++)
-    {
-       magRaw[i] = (int)sensorBuffer[(i * 2) + 1] | ((int)sensorBuffer[i * 2] << 8);
-    }    
+}
+
+//--------------------------------------------------------------------------------------
+void UpdateSensors()
+{
+    readAccelRaw();
+    readGyroRaw();
+    readCompassRaw();
 }
 
 //--------------------------------------------------------------------------------------
@@ -235,29 +280,24 @@ void UpdateSensors()
 //--------------------------------------------------------------------------------------
 void SetGyroOffset()
 {
-    // Not sure what the outer loops are for, Dennis. Stabilization time?
-    //
-    for (unsigned int i = 0; i < 100; i++)
-    {
-        UpdateSensors();
-        for (unsigned char k = 0; k < 3; k++)
-        {
-            gyroOff[k] += gyroRaw[k];
+    sets.gyroOff[0] = sets.gyroOff[1] = sets.gyroOff[2] = 0;
+
+#define GYRO_AVG 256
+
+    for (int i = 0; i < GYRO_AVG; i++)  {
+	delay(5);
+        readGyroRaw();
+        for (byte k = 0; k < 3; k++) {
+            sets.gyroOff[k] += gyroRaw[k];
         }
     }
  
-    for (unsigned char k = 0; k < 3; k++)
-    {
-        gyroOff[k] = gyroOff[k] / 100;
-    }
+    sets.gyroOff[0] /= GYRO_AVG;
+    sets.gyroOff[1] /= GYRO_AVG;
+    sets.gyroOff[2] /= GYRO_AVG;
      
 #if (DEBUG)     
-    Serial.print("Gyro offset measured:");
-    Serial.print(gyroOff[0]);
-    Serial.print(",");   
-    Serial.print(gyroOff[1]);
-    Serial.print(",");      
-    Serial.println(gyroOff[2]);    
+    Serial.printf_P(PSTR("Gyro offset measured: %f %f %f\n"), sets.gyroOff[0], sets.gyroOff[1], sets.gyroOff[2]);
 #endif 
 }
 
@@ -265,78 +305,136 @@ void SetGyroOffset()
 // Func: CalibrateMag
 // Desc: 
 //--------------------------------------------------------------------------------------
-void CalibrateMag()
-{  
-    WriteToI2C(HMC_ADDR, 0x00, 0b00010001);
+void CalibrateMag() { 
+#define AVG_COUNT 32
 
-    // MM: Again with the loops. Not sure what purpose this serves, Dennis.
-    for (unsigned char i = 0; i < 40; i++)
-    {
-        UpdateSensors(); 
+    magPosOff[0] = magPosOff[1] = magPosOff[2] = magNegOff[0] = magNegOff[1] = magNegOff[2] = 0;
+
+    WriteToI2C(HMC_ADDR,ModeRegister, SingleConversion);
+    delay(10);
+    WriteToI2C(HMC_ADDR, ConfigRegA, SampleAveraging_1<<5 | DataOutputRate_75HZ<<2 | PositiveBiasConfig);        // force positiveBias (compass should return 715 for all channels)
+    delay(10);
+
+    WriteToI2C(HMC_ADDR, ModeRegister, ContinuousConversion);
+    
+    for (byte i = 0; i < AVG_COUNT; i++)  {
+        // read values from the compass
+        delay(14);
+        readCompassRaw();
+	magPosOff[0] += magRaw[0];
+	magPosOff[1] += magRaw[1];
+	magPosOff[2] += magRaw[2];  
     }
-    magPosOff[0] = magRaw[0];
-    magPosOff[1] = magRaw[1];
-    magPosOff[2] = magRaw[2];  
   
   
-    WriteToI2C(HMC_ADDR, 0x00, 0b00010010);
+    WriteToI2C(HMC_ADDR,ModeRegister, SingleConversion);
+    delay(10);
+    WriteToI2C(HMC_ADDR, ConfigRegA, SampleAveraging_1<<5 | DataOutputRate_75HZ<<2 | NegativeBiasConfig);
+    delay(10);
+    WriteToI2C(HMC_ADDR,ModeRegister,  ContinuousConversion);
 
-    for (unsigned char i = 0; i < 40; i++)
-    {
-        UpdateSensors(); 
+    for (byte i = 0; i < AVG_COUNT; i++)  {
+        // read values from the compass
+        delay(14);
+        readCompassRaw();
+	magNegOff[0] += magRaw[0];
+        magNegOff[1] += magRaw[1];
+	magNegOff[2] += magRaw[2];
     }
-    magNegOff[0] = magRaw[0];
-    magNegOff[1] = magRaw[1];
-    magNegOff[2] = magRaw[2];  
     
-    WriteToI2C(HMC_ADDR, 0x00, 0b00010000);
+    WriteToI2C(HMC_ADDR,ModeRegister, SingleConversion);
+    delay(10);
+    WriteToI2C(HMC_ADDR, ConfigRegA, compass_mode);
+    delay(10);
+    WriteToI2C(HMC_ADDR,ModeRegister, ContinuousConversion);
 
-    magGain[0] = -2500 / float(magNegOff[0] - magPosOff[0]);
-    magGain[1] = -2500 / float(magNegOff[1] - magPosOff[1]);
-    magGain[2] = -2500 / float(magNegOff[2] - magPosOff[2]); 
   
-    for (unsigned char i = 0; i < 40; i++)
-    {
-        UpdateSensors(); 
+    magPosOff[0] /= AVG_COUNT;
+    magPosOff[1] /= AVG_COUNT;
+    magPosOff[2] /= AVG_COUNT;
+
+    magNegOff[0] /= AVG_COUNT;
+    magNegOff[1] /= AVG_COUNT;
+    magNegOff[2] /= AVG_COUNT;
+
+    magGain[0] = -2500 / (magNegOff[0] - magPosOff[0]);
+    magGain[1] = -2500 / (magNegOff[1] - magPosOff[1]);
+    magGain[2] = -2500 / (magNegOff[2] - magPosOff[2]);
+
+
+    float magTmp[3]={0,0,0};
+
+    magMGain[0]=magMGain[1]=magMGain[2]=1; // without norma
+
+// calibrate norm
+    for (byte i = 0; i < AVG_COUNT; i++)  {
+        // read values from the compass
+        delay(14);
+	getCompass();
+	magTmp[0] += magV[0];
+	magTmp[1] += magV[1];
+	magTmp[2] += magV[2];  
     }  
   
+    magTmp[0] /= AVG_COUNT;
+    magTmp[1] /= AVG_COUNT;
+    magTmp[2] /= AVG_COUNT;
+
+    MR = sqrt(magTmp[0]*magTmp[0] + magTmp[1]*magTmp[1] + magTmp[2]*magTmp[2]);
+
+    magMGain[0] = magGain[0]/(MR * sets.magGain[0]); // калибровочная нормировка
+    magMGain[1] = magGain[1]/(MR * sets.magGain[1]);
+    magMGain[2] = magGain[2]/(MR * sets.magGain[2]);
+
 #if (DEBUG)
-    Serial.print("Mag cal:");
-    Serial.print(magNegOff[0] - magPosOff[0]);
-    Serial.print(",");   
-    Serial.print(magNegOff[1] - magPosOff[1]);
-    Serial.print(",");      
-    Serial.print(magNegOff[2] - magPosOff[2]);
-   
-    Serial.print(",");      
-    Serial.print(magGain[0]);
-    Serial.print(",");   
-    Serial.print(magGain[1]);
-    Serial.print(",");      
-    Serial.println(magGain[2]);   
-   
-   
-    Serial.print("Mag offset:");
-    Serial.print(magOffset[0]);
-    Serial.print(",");   
-    Serial.print(magOffset[1]);
-    Serial.print(",");      
-    Serial.println(magOffset[2]);    
+//    Serial.printf_P(PSTR("Mag type: %i\n"), compass);
+    Serial.printf_P(PSTR("Mag cal: %f:%f, %f:%f, %f:%f, gain: %f %f %f\n"), magNegOff[0] , magPosOff[0], magNegOff[1], magPosOff[1], magNegOff[2], magPosOff[2], magGain[0], magGain[1], magGain[2]);
+//    Serial.printf_P(PSTR("Mag offset: %f %f %f\n"), sets.magOffset[0], sets.magOffset[1], sets.magOffset[2]);
+//    Serial.printf_P(PSTR("Mag gain:   %f %f %f\n"), sets.magGain[0], sets.magGain[1], sets.magGain[2]);
+
+//    Serial.printf_P(PSTR("Mag tmp: %f %f %f\n"), magTmp[0], magTmp[1], magTmp[2]);
+//    Serial.printf_P(PSTR("Mag norm: %f\n"), MR);
+//    Serial.printf_P(PSTR("Mag norm gain: %f %f %f\n"), magMGain[0], magMGain[1], magMGain[2]);
 #endif          
 }
 
+void getCompass(){
+    readCompassRaw();
+
+    if (magRaw[0] == -4096)
+	magV[0]=0;
+    else
+        magV[0] =  (magRaw[0] - sets.magOffset[0]) * magMGain[0]; // / MR / sets.magGain[0];
+    
+    if (magRaw[1] == -4096)
+	magV[1]=0;
+    else
+	magV[1] = (-magRaw[1] - sets.magOffset[1]) * magMGain[1];
+
+
+    if (magRaw[2] == -4096)
+	magV[2]=0;
+    else
+	magV[2] = (-magRaw[2] - sets.magOffset[2]) * magMGain[2];
+
+}
+
 
 //--------------------------------------------------------------------------------------
 // Func: GyroCalc
 // Desc: Calculate angle from gyro-data
 //--------------------------------------------------------------------------------------
-void GyroCalc()
-{    
-#if (DEBUG)
-    for (unsigned char i=0; i<3; i++)
-    {
-        angleRaw[i]+=((gyroRaw[i]-gyroOff[i]));
-        angle[i] = angleRaw[i]/(SAMPLERATE*SCALING_FACTOR);
+void GyroCalc() {
+    readGyroRaw();
+
+    gyro[0] = gyroRaw[0]-sets.gyroOff[0];
+    gyro[1] = gyroRaw[1]-sets.gyroOff[1];
+    gyro[2] = gyroRaw[2]-sets.gyroOff[2];
+
+#if DEBUG
+    for (byte i=0; i<3; i++) {
+        angleRaw[i]  += gyro[i];
+        gyroAngle[i]  = angleRaw[i] / (SAMPLERATE*SCALING_FACTOR);
     }
 #endif          
 }
@@ -345,85 +444,167 @@ void GyroCalc()
 // Func: AccelCalc
 // Desc: Calculate angle from accelerometer data
 //--------------------------------------------------------------------------------------
-void AccelCalc()
-{
-    accRaw[0] += accOffset[0];
-    accRaw[1] += accOffset[1];
-    accRaw[2] += accOffset[2];   
   
-    for (unsigned char i = 0; i<3; i++)
-    {
-        accG[i] = (float)accRaw[i] / ACC_SENS;
-    }
      
+#define SCALE_FACTOR_X                                  7.604562738 // mg/LSB
+#define SCALE_FACTOR_Y                                  7.604562738 // mg/LSB
+#define SCALE_FACTOR_Z                                  7.8125      // mg/LSB
+#define GRAVITATIONAL_ACCELERATION                      9.81 //meter/sec/sec
+
+void getAccel(){
+    readAccelRaw();
+    
+/*    accG[0] = ((float)accRaw[0] + sets.accOffset[0] ) / ACC_SENS;
+    accG[1] = ((float)accRaw[1] + sets.accOffset[1] ) / ACC_SENS;
+    accG[2] = ((float)accRaw[2] + sets.accOffset[2] ) / ACC_SENS;
+*/
+    accG[0] = ((float)accRaw[0] + sets.accOffset[0] ) * SCALE_FACTOR_X * GRAVITATIONAL_ACCELERATION / 1000.0 / 2 / sets.accGain[0];
+    accG[1] = ((float)accRaw[1] + sets.accOffset[1] ) * SCALE_FACTOR_Y * GRAVITATIONAL_ACCELERATION / 1000.0 / 2 / sets.accGain[1];
+    accG[2] = ((float)accRaw[2] + sets.accOffset[2] ) * SCALE_FACTOR_Z * GRAVITATIONAL_ACCELERATION / 1000.0 / 2 / sets.accGain[2];
+
+}
+
+void CalibrateAccel(){
+#define ACCEL_AVG 64
     // So, lets calculate R
     // R^2 = Rx^2+Ry^2+Rz^2    
-    #if (ASSUME_1G_ACC == 0) 
-        R = sqrt((accG[0] * accG[0]) + (accG[1] * accG[1]) + (accG[2] * accG[2]));
-    #else // Otherwise, just assume total G = 1.
-        R = 1;
-    #endif
+    float x=0,y=0,z=0;
       
-    // Calculate final angles:
-    if (R < 1.3 && R > 0.7)
-    { 
-        for (unsigned char i = 0; i<3; i++)
-        {
-            accAngle[i] = acos(accG[i] / R) * 57.3;
+// skip first measurements
+/*    for(byte i=0;i<ACCEL_AVG;i++){
+	delay(18);	// 50hz
+
+	getAccel();
+    }
+*/
+ 
+    for(byte i=0;i<ACCEL_AVG;i++){
+	delay(18);	// 50hz
+
+	getAccel();
+
+	x+=accG[0];
+	y+=accG[1];
+	z+=accG[2];
         }  
+
+    x /= ACCEL_AVG;
+    y /= ACCEL_AVG;
+    z /= ACCEL_AVG;
+
+    R = sqrt((x*x) + (y*y) + (z*z));
+
+}
+
+void AccelCalc(){	    // Calculate final angles:
+    getAccel();
+
+/*    
+    for (byte i = 0; i<3; i++) {
+	float v=accG[i] / R;
+
+
+	if(v < -1)
+	    accAngle[i] = 180;
+	else if(v > 1)
+	    accAngle[i] = 0;
+	else
+	    accAngle[i] = acos(v) * TO_GRADUS;
     }
+*/
+
+	float p;
+	p=-accG[0] / R;
+	if(p < -1)
+	    accAngle[0] = -90;
+	else if(p > 1)
+	    accAngle[0] =  90;
+	else
+	    accAngle[0] = (p=asin(p) ) * TO_GRADUS;
+	
+	p=(accG[1] / R) / cos(p);
+	
+	if(accAngle[0] == -90 || accAngle[0] == 90)
+	    accAngle[1]=0;
+	else if(p < -1)
+	    accAngle[1] = -90;
+	else if(p > 1)
+	    accAngle[1] = 90;
+	else
+	    accAngle[1] = asin( p ) * TO_GRADUS;
+
 }
 
 //--------------------------------------------------------------------------------------
 // Func: MagCalc
 // Desc: Calculates angle from magnetometer data.
 //--------------------------------------------------------------------------------------
-void MagCalc()
-{
-    // Invert 2 axis  
-    magRaw[1] *= -1;
-    magRaw[2] *= -1;
-    
-    // Set gain:
-    magRaw[0] *= magGain[0];
-    magRaw[1] *= magGain[1];
-    magRaw[2] *= magGain[2];    
-    
-    magRaw[0] -= magOffset[0];
-    magRaw[1] -= magOffset[1];
-    magRaw[2] -= magOffset[2];    
-  
-    float testAngle = tiltAngle - 90;
-    mx = magRaw[0] * cos((testAngle) / 57.3)
-        + magRaw[1] * sin(testAngle / 57.3);
-
-    my = magRaw[0] * sin((rollAngle - 90) / 57.3)
-        * sin((tiltAngle - 90) / 57.3)
-        + magRaw[2] * cos((rollAngle - 90) / 57.3)
-        - magRaw[1] * sin((rollAngle - 90) / 57.3)
-        * cos((tiltAngle - 90) / 57.3);
+void CalcMagAngle(){
+/* calculated early
+    float tilt90 = tiltAngle - 90, roll90 = rollAngle - 90,
+        sin_tilt = sin(tilt90 * FROM_GRADUS),
+        cos_tilt = cos(tilt90 * FROM_GRADUS),
+        sin_roll = sin(roll90 * FROM_GRADUS),
+        cos_roll = cos(roll90 * FROM_GRADUS);
+*/
       
-    // Calculate pan-angle from magnetometer. 
-    magAngle[2] = (atan(mx / my) * 57.3 + 90);
 
-    // Get full 0-360 degrees. 
-    if (my < 0)
-    {
-        magAngle[2] += 180;
-    }
+/*
+    mx  = magV[0] * cos_tilt
+        + magV[1] * sin_tilt;
     
-    float tempAngle = panStart - magAngle[2];
+    my =  magV[0] * sin_roll * sin_tilt
+        + magV[2] * cos_roll
+        - magV[1] * sin_roll * cos_tilt;
+*/
       
-    if (tempAngle > 180)
-    {
-        tempAngle -= 360; 
+
+// tilt/roll compensation
+
+    mx  = magV[0] * cos_tilt
+        + magV[2] * sin_tilt;
+
+    my =  magV[0] * sin_roll * sin_tilt
+        + magV[1] * cos_roll
+	- magV[2] * sin_roll * cos_tilt;
+
+    mz = -magV[0] * cos_roll * sin_tilt
+        + magV[1] * sin_roll
+	+ magV[2] * cos_roll * cos_tilt;
+  
+  
+    if(mx==0 && my==0)
+	magAngle[2]=90;
+    else {
+	// Calculate pan-angle from magnetometer. 
+//	magAngle[2] = atan2(mx, my) * TO_GRADUS + 90;
+	magAngle[2] = atan2(my, mx) * TO_GRADUS + 90;
     }  
-    else if (tempAngle < -180)
-    {
-        tempAngle += 360; 
+  
+    if (magAngle[2] > 180) {
+        magAngle[2] -= 360;
+    } else if (magAngle[2] < -180) {
+        magAngle[2] += 360; 
     }
+}
+
+void MagCalc(){
       
-    magAngle[2] = tempAngle * -1;
+    getCompass();
+
+    CalcMagAngle();
+}
+
+
+// reset normas
+void CalibrationStart(){
+    sets.magOffset[0]=sets.magOffset[1]=sets.magOffset[2]=0;
+    sets.accOffset[0]=sets.accOffset[1]=sets.accOffset[2]=0;
+
+    sets.magGain[0]=sets.magGain[1]=sets.magGain[2]=1;
+    sets.accGain[0]=sets.accGain[1]=sets.accGain[2]=1;
+    
+    magMGain[0]=sets.magOffset[1]=sets.magOffset[2]=1;
 }
 
 
@@ -436,68 +617,104 @@ void FilterSensorData()
     int temp = 0;
 
     // Used to set initial values. 
-    if (resetValues == 1)
-    {
+    if (resetValues) {
 #if FATSHARK_HT_MODULE
         digitalWrite(BUZZER, HIGH);
 #endif
+	digitalWrite(ARDUINO_LED, HIGH); 
         resetValues = 0; 
       
-        tiltStart = 0;
-        panStart = 0;
-        rollStart = 0;
   
-        UpdateSensors();    
+        tiltStart = panStart = rollStart = 0;
+
+	for(byte i=0; i<4; i++){  
         GyroCalc();
         AccelCalc();
         MagCalc();
         
-        panAngle = 0;
         tiltStart = accAngle[0];
-        panStart = magAngle[2];
         rollStart = accAngle[1];
+            panStart  = magAngle[2];
+	}
+	
+
+        tiltStart /= 4;
+        rollStart /= 4;
+        panStart  /= 4;
+
+        panAngle = 0;
+
+//        tiltStart = tiltAngle;
+//        panStart =  rollAngle;
+//        rollStart = panAngle;
+
+
+#if DEBUG
+    Serial.printf_P(PSTR("Center reset! tilt=%f rol=%f pan=%f\n"), tiltStart, rollStart, panStart);
+#endif
 
 #if FATSHARK_HT_MODULE
         digitalWrite(BUZZER, LOW);
 #endif
+	digitalWrite(ARDUINO_LED, LOW); //ready
     }
+    float ta = (tiltAngle - 90) * FROM_GRADUS,
+	  ra = (rollAngle - 90) * FROM_GRADUS;
+
+
+    // Filter the high frequency noise from vibrations 
+    accG[0] = computeFourthOrder(accG[0], &fourthOrder[0]);
+    accG[1] = computeFourthOrder(accG[1], &fourthOrder[1]);
+    accG[2] = computeFourthOrder(accG[2], &fourthOrder[2]);
+
+    cos_tilt=cos(ta);
+    sin_tilt=sin(ta);
+    cos_roll=cos(ra);
+    sin_roll=sin(ra);
+
+
+    float magA = magAngle[2] - panStart;
+    if (magA > 180) {
+        magA -= 360;
+    } else if (magA < -180) {
+        magA += 360; 
+    }
+
 
     // Simple FilterSensorData, uses mainly gyro-data, but uses accelerometer to compensate for drift
-    rollAngle = (rollAngle + ((gyroRaw[0] - gyroOff[0]) * cos((tiltAngle - 90) / 57.3) +  (gyroRaw[2] - gyroOff[2]) *  sin((tiltAngle - 90) / 57.3)) / (SAMPLERATE * SCALING_FACTOR)) * gyroWeightTiltRoll +                                                                    accAngle[1] * (1 - gyroWeightTiltRoll);
-    tiltAngle = (tiltAngle + ((gyroRaw[1] - gyroOff[1]) * cos((rollAngle - 90) / 57.3) +  (gyroRaw[2] - gyroOff[2]) * -sin((rollAngle - 90) / 57.3)) / (SAMPLERATE * SCALING_FACTOR)) * gyroWeightTiltRoll +                                                                    accAngle[0] * (1 - gyroWeightTiltRoll);
-    panAngle  = (panAngle  + ((gyroRaw[2] - gyroOff[2]) * cos((tiltAngle - 90) / 57.3) + ((gyroRaw[0] - gyroOff[0]) * -sin((tiltAngle - 90) / 57.3) ) + ( ((gyroRaw[1] - gyroOff[1]) * 1) * (sin((rollAngle - 90) / 57.3)))) / (SAMPLERATE * SCALING_FACTOR)) * GyroWeightPan + magAngle[2] * (1 - GyroWeightPan);
+    rollAngle = (rollAngle + (gyro[0] *  cos_tilt +  gyro[2] *  sin_tilt)                          / (SAMPLERATE * SCALING_FACTOR)) * sets.gyroWeightTiltRoll + accAngle[1] * (1 - sets.gyroWeightTiltRoll);
+    tiltAngle = (tiltAngle + (gyro[1] *  cos_roll +  gyro[2] * -sin_roll)                          / (SAMPLERATE * SCALING_FACTOR)) * sets.gyroWeightTiltRoll + accAngle[0] * (1 - sets.gyroWeightTiltRoll);
+    panAngle  = (panAngle  + (gyro[2] *  cos_tilt + (gyro[0] * -sin_tilt) + ( gyro[1] * sin_roll)) / (SAMPLERATE * SCALING_FACTOR)) * sets.gyroWeightPan      + magA        * (1 - sets.gyroWeightPan);
 
-    if (TrackerStarted)
-    {
+    if (TrackerStarted)  {
         // All low-pass filters
-        tiltAngleLP = tiltAngle * tiltRollBeta + (1 - tiltRollBeta) * lastTiltAngle;
+        tiltAngleLP = tiltAngle * sets.tiltRollBeta + (1 - sets.tiltRollBeta) * lastTiltAngle;
         lastTiltAngle = tiltAngleLP;
   
-        rollAngleLP = rollAngle * tiltRollBeta + (1 - tiltRollBeta) * lastRollAngle;
+        rollAngleLP = rollAngle * sets.tiltRollBeta + (1 - sets.tiltRollBeta) * lastRollAngle;
         lastRollAngle = rollAngleLP;
 
-        panAngleLP = panAngle * panBeta + (1 - panBeta) * lastPanAngle;
+        panAngleLP = panAngle * sets.panBeta        + (1 - sets.panBeta) * lastPanAngle;
         lastPanAngle = panAngleLP;
 
-        float panAngleTemp = panAngleLP * panInverse * panFactor;
-        if ( (panAngleTemp > -panMinPulse) && (panAngleTemp < panMaxPulse) )
         {
-            temp = servoPanCenter + panAngleTemp;
-            channel_value[htChannels[0]] = (int)temp;
+            float angleTemp = (panAngleLP - panStart)  * sets.panFactor * dynFactor + sets.servoPanCenter;
+            if ( (angleTemp > sets.panMinPulse) && (angleTemp < sets.panMaxPulse) )  {
+                channel_value[sets.htChannels[0]] =  angleTemp;
+            }    
         }    
-
-        float tiltAngleTemp = (tiltAngleLP - tiltStart) * tiltInverse * tiltFactor;
-        if ( (tiltAngleTemp > -tiltMinPulse) && (tiltAngleTemp < tiltMaxPulse) )
         {
-            temp = servoTiltCenter + tiltAngleTemp;
-            channel_value[htChannels[1]] = temp;
+            float angleTemp = (tiltAngleLP - tiltStart) *  sets.tiltFactor * dynFactor + sets.servoTiltCenter;
+            if ( (angleTemp > sets.tiltMinPulse) && (angleTemp < sets.tiltMaxPulse) ) {
+                channel_value[sets.htChannels[1]] =  angleTemp;
+            }
         }   
 
-        float rollAngleTemp = (rollAngleLP - rollStart) * rollInverse * rollFactor;
-        if ( (rollAngleTemp > -rollMinPulse) && (rollAngleTemp < rollMaxPulse) )
         {
-            temp = servoRollCenter + rollAngleTemp;
-            channel_value[htChannels[2]] = temp;
+            float angleTemp = (rollAngleLP - rollStart) * sets.rollFactor * dynFactor + sets.servoRollCenter;
+            if ( (angleTemp > sets.rollMinPulse) && (angleTemp < sets.rollMaxPulse) ) {
+                channel_value[sets.htChannels[2]] =  angleTemp;
+            }
         }
     }
 }
@@ -509,32 +726,29 @@ void FilterSensorData()
 void InitSensors()
 {
     ReadFromI2C(ITG3205_ADDR, 0x00, 1);
-    ITG3205_ID = sensorBuffer[0];
+    ITG3205_ID = sb.sensorBuffer[0];
  
-#if (DEBUG)    
-    Serial.print("ITG3205: ");
-    Serial.print(sensorBuffer[0]);
+#if DEBUG
+    Serial.printf_P(PSTR("ITG3205: %d\n"), ITG3205_ID);
 #endif 
  
     ReadFromI2C(ADXL345_ADDR, 0x00, 1);
-    ADXL345_ID = sensorBuffer[0];
+    ADXL345_ID = sb.sensorBuffer[0];
  
-#if (DEBUG)     
-    Serial.print("    ADXL: ");
-    Serial.print(sensorBuffer[0]); 
+#if DEBUG
+    Serial.printf_P(PSTR("    ADXL: %d\n"), ADXL345_ID); 
 #endif  
 
     // Accelerometer increase G-range (+/- 16G)
     WriteToI2C(ADXL345_ADDR, 0x31, 0b00001011);        
     ReadFromI2C(HMC_ADDR, 0x00, 1);
-    HMC_ID = sensorBuffer[0];
+    HMC_ID = sb.sensorBuffer[0];
  
-#if (DEBUG)     
-    Serial.print("    HMC: ");
-    Serial.println(sensorBuffer[0]); 
+#if DEBUG
+    Serial.printf_P(PSTR("    HMC: %d\n"), HMC_ID); 
 #endif  
 
-    WriteToI2C(ITG3205_ADDR, 22, 24);
+    WriteToI2C(ITG3205_ADDR, 22, 0x18 | 2); //Register 22 – DLPF, Full Scale - full range 98hz filter
 
     //  ADXL345 POWER_CTL
     WriteToI2C(ADXL345_ADDR, 0x2D, 0); 
@@ -542,8 +756,52 @@ void InitSensors()
     WriteToI2C(ADXL345_ADDR, 0x2D, 8);
 
     // HMC5883
+    
+    uint8_t calibration_gain = 0b00100000 ;//0x20;  - 820
+//    uint16_t expected_x = 715;
+//    uint16_t expected_yz = 715;
+//    float gain_multiple = 1.0;
+
+//    WriteToI2C(HMC_ADDR, 0x00, 0b01111000); //crA - 8avg 75hz normal
+    compass_mode = SampleAveraging_8<<5 | DataOutputRate_75HZ<<2 | NormalOperation;
+    WriteToI2C(HMC_ADDR, ConfigRegA, compass_mode);
+    ReadFromI2C(HMC_ADDR, ConfigRegA, 1);
+    byte d = sb.sensorBuffer[0];
+    
+    if(d == compass_mode) {        // a 5883L supports the sample averaging config
+
+#if DEBUG
+//    Serial.print_P(PSTR("compass type HMC5883L\n")); 
+#endif  
+
+        compass = AP_COMPASS_TYPE_HMC5883L;
+//        calibration_gain = 0b01100000; //0x60; - 660
+//        calibration_gain = 0b11100000; //  230
+        calibration_gain = 0b10000000; //  440
+        /*
+          note that the HMC5883 datasheet gives the x and y expected
+          values as 766 and the z as 713. Experiments have shown the x
+          axis is around 766, and the y and z closer to 713.
+         */
+//        expected_x = 766;
+//        expected_yz  = 713;
+//        gain_multiple = 660.0 / 1090;  // adjustment for runtime vs calibration gain
+        
+    } else if ( d == (NormalOperation | DataOutputRate_75HZ<<2)) {
+#if DEBUG
+//    Serial.print_P(PSTR("compass type HMC5883\n")); 
+#endif  
+	compass = AP_COMPASS_TYPE_HMC5843;
+    } else {
+
+	Serial.printf_P(PSTR("Error detecting compass! %x - %x\n"), d, compass_mode);
+	compass = 0;
+	digitalWrite(ARDUINO_LED, HIGH);
+    }
+
+    WriteToI2C(HMC_ADDR, ConfigRegB, calibration_gain); //crB - gain 660
     // Run in continuous mode
-    WriteToI2C(HMC_ADDR, 0x02, 0x00);    
+    WriteToI2C(HMC_ADDR, ModeRegister, ContinuousConversion); //mode = 0
  
 #if (ALWAYS_CAL_GYRO)
     // Set sensor offset
@@ -562,9 +821,8 @@ void ResetCenter()
     
     // Not sure what Dennis is doing here. Giving it
     // time to stabilize, since this is called at setup time?
-    for (unsigned char k = 0; k < 250; k++)
-    {
-        UpdateSensors();    
+    for (byte k = 0; k < 16; k++) {
+//        UpdateSensors();    
         GyroCalc();
         AccelCalc();
         MagCalc();
@@ -572,18 +830,21 @@ void ResetCenter()
     }
     
     tiltStart = accAngle[0];
-    panStart = magAngle[2];
     rollStart = accAngle[1];  
+    panStart  = magAngle[2];
   
-    UpdateSensors();    
     GyroCalc();
     AccelCalc();
     MagCalc();
     FilterSensorData();    
   
-    panAngle = magAngle[2];
     tiltAngle = accAngle[0];
     rollAngle = accAngle[1];
+    panAngle  = magAngle[2];
+
+#if DEBUG
+    Serial.printf_P(PSTR("Center reset v2! tilt=%f rol=%f pan=%f\n"), tiltStart, rollStart, panStart);
+#endif
     
     TrackerStarted = 1;
 }
@@ -594,165 +856,125 @@ void ResetCenter()
 //--------------------------------------------------------------------------------------
 void SensorInfoPrint()
 { 
-   Serial.print("Mag cal:");
-   Serial.print(magNegOff[0] - magPosOff[0]);
-   Serial.print(",");   
-   Serial.print(magNegOff[1] - magPosOff[1]);
-   Serial.print(",");      
-   Serial.print(magNegOff[2] - magPosOff[2]);
-   
-   Serial.print(",");      
-   Serial.print(magGain[0]);
-   Serial.print(",");   
-   Serial.print(magGain[1]);
-   Serial.print(",");      
-   Serial.println(magGain[2]);   
-
-   Serial.print("ADXL345 ID: ");
-   Serial.println((int)ADXL345_ID); 
-   Serial.print("ITG3205 ID: ");
-   Serial.println((int)ITG3205_ID); 
-   Serial.print("HMC ID: ");
-   Serial.println((int)HMC_ID);   
+   Serial.printf_P(PSTR("Mag cal: %f,%f,%f,%f,%f,%f\n"), magNegOff[0] - magPosOff[0], magNegOff[1] - magPosOff[1], magNegOff[2] - magPosOff[2], 
+					   magGain[0], magGain[1], magGain[2]);   
+
+   Serial.printf_P(PSTR("ADXL345 ID: %d\nITG3205 ID: %d\nHMC ID: %d\n"), (int)ADXL345_ID, (int)ITG3205_ID,  (int)HMC_ID);
+
+//   Serial.printf_P(PSTR("R= %f gyroWeightTiltRoll=%f gyroWeightPan=%f\n"), R, sets.gyroWeightTiltRoll, sets.gyroWeightPan );
 }
 
 
 // ===============================================
 //      ---------- Test functions -----------
 // ===============================================
-/*
-void testAccOutput()
-{
-    Serial.print("RAW: ");  
-    Serial.print(accRaw[0]);  
-    Serial.print(" ");          
-    Serial.print(accRaw[1]);  
-    Serial.print(" ");              
-    Serial.print(accRaw[2]);  
 
-    Serial.print("\t G: ");        
-    Serial.print(accG[0]); 
-    Serial.print(" ");    
-    Serial.print(accG[1]); 
-    Serial.print(" "); 
-    Serial.print(accG[2]); 
-
-    Serial.print("\t Ang: ");        
-    Serial.print(accAngle[0]); 
-    Serial.print(" ");    
-    Serial.print(accAngle[1]); 
-    Serial.print(" "); 
-    Serial.println(accAngle[2]);
+#if DEBUG
+void testAccOutput() // dbg1
+{
+    Serial.printf_P(PSTR("raw: %d,%d,%d\n"), accRaw[0], accRaw[1], accRaw[2]);
+    Serial.printf_P(PSTR("G:   %f,%f,%f R=%f\n"), accG[0], accG[1], accG[2],R);
+    Serial.printf_P(PSTR("ang: %f,%f,%f\n"), accAngle[0], accAngle[1], accAngle[2]);
 }
 
-void testGyroOutput()
+void testGyroOutput() // dbg2
 {  
-    Serial.print("RAW: ");  
-    Serial.print(gyroRaw[0]);  
-    Serial.print(",");          
-    Serial.print(gyroRaw[1]);  
-    Serial.print(",");              
-    Serial.print(gyroRaw[2]);   
+    Serial.printf_P(PSTR("raw: %d,%d,%d\n"), gyroRaw[0], gyroRaw[1], gyroRaw[2]);
+    Serial.printf_P(PSTR("ang: %f,%f,%f\n"), gyroAngle[0], gyroAngle[1], gyroAngle[2]);
 
-    Serial.print(",");        
-    Serial.print(angle[0]);  
-    Serial.print(",");          
-    Serial.print(angle[1]);  
-    Serial.print(",");              
-    Serial.println(angle[2]);
 }
 
-void testMagOutput()
+void testMagOutput() // dbg4
 {
-    Serial.print(magRaw[0]);
-    Serial.print(",");
-    Serial.print(magRaw[1]);
-    Serial.print(",");    
-    Serial.print(magRaw[2]);    
-
-    Serial.print(",");              
-    Serial.print(magAngle[0]);  
-    Serial.print(",");          
-    Serial.print(magAngle[1]);  
-    Serial.print(",");              
-    Serial.println(magAngle[2]);      
+    Serial.printf_P(PSTR("raw:  %d,%d,%d\n"), magRaw[0], magRaw[1], magRaw[2]);
+    Serial.printf_P(PSTR("norm: %f,%f,%f\n"), magV[0], magV[1], magV[2]);
+    Serial.printf_P(PSTR(" m*:  %f,%f,%f\n"), mx, my, mz);
+    Serial.printf_P(PSTR("cal:  %f,%f,%f\n"), magAngle[0], magAngle[1], magAngle[2]);
 }
 
 void testTiltOutput()
 { 
-    Serial.print(angle[1]);
-    Serial.print(",");          
-    Serial.print(accAngle[0]-tiltStart);
-    Serial.print(",");          
-    Serial.println(tiltAngle-tiltStart);
+    Serial.printf_P(PSTR("tilt: %f,%f,%f\n"), gyroAngle[1], accAngle[0]-tiltStart, tiltAngle-tiltStart);
 }
 
 void testRollOutput()
 {
-    Serial.print(angle[0]);
-    Serial.print(",");          
-    Serial.print(accAngle[1]-rollStart);
-    Serial.print(",");          
-    Serial.println(rollAngle-rollStart);  
+    Serial.printf_P(PSTR("roll: %f,%f,%f\n"), gyroAngle[0], accAngle[1]-rollStart, rollAngle-rollStart);
 }
 
 void testPanOutput()
 {
-    Serial.print(angle[2]);
-    Serial.print(",");                  
-    Serial.print(magAngle[2]);
-    Serial.print(",");                  
-    Serial.println(panAngle);
+    Serial.printf_P(PSTR("pan: %f,%f,%f\n"), gyroAngle[2], magAngle[2], panAngle);
 }
 
 // output calculated values, output as "csv"
 void testAllData()
 {  
-    // x
-  Serial.print(angle[1]);
-  Serial.print(",");          
-  Serial.print(accAngle[0]-90);
-  Serial.print(",");          
-  Serial.print(tiltAngle-90);
-  Serial.print(",");      
-  
-    // y
-  Serial.print(angle[0]);
-  Serial.print(",");          
-  Serial.print(accAngle[1]-90);
-  Serial.print(",");          
-  Serial.print(rollAngle-90);  
-  Serial.print(",");     
-    
-    // z
-  Serial.print(angle[2]);
-  Serial.print(",");                  
-  Serial.print(magAngle[2]-panStart);
-  Serial.print(",");                  
-  Serial.println(panAngle);
+    Serial.printf_P(PSTR("tilt: %f,%f,%f (0=%f)\n"), gyroAngle[1], accAngle[0], tiltAngle, tiltStart);
+    Serial.printf_P(PSTR("roll: %f,%f,%f (0=%f)\n"), gyroAngle[0], accAngle[1], rollAngle, rollStart);
+    Serial.printf_P(PSTR("pan:  %f,%f,%f (0=%f)\n"), gyroAngle[2], magAngle[2], panAngle,  panStart);
 }
 
 // All sensor output as "csv". 
 void testAllSensors()
 {  
     Serial.print(accRaw[0]);  
-    Serial.print(",");          
+    Serial.write(',');          
     Serial.print(accRaw[1]);  
-    Serial.print(",");              
+    Serial.write(',');              
     Serial.print(accRaw[2]);  
 
-    Serial.print(",");            
+    Serial.write(',');            
     Serial.print(gyroRaw[0]);  
-    Serial.print(",");          
+    Serial.write(',');          
     Serial.print(gyroRaw[1]);  
-    Serial.print(",");              
+    Serial.write(',');              
     Serial.print(gyroRaw[2]);  
 
-    Serial.print(",");               
+    Serial.write(',');               
     Serial.print(magRaw[0]);  
-    Serial.print(",");          
+    Serial.write(',');          
     Serial.print(magRaw[1]);  
-    Serial.print(",");              
+    Serial.write(',');              
     Serial.println(magRaw[2]);      
 }
-*/
+#endif
+
+void clearSettings() {
+    sets.vers = EEPROM_VERSION;
+
+    sets.tiltRollBeta = 0.85;
+    sets.panBeta = 0.85;
+    sets.gyroWeightTiltRoll = 0.98;
+    sets.gyroWeightPan = 0.98;
+
+    sets.servoPanCenter = 1500;
+    sets.servoTiltCenter = 1500;
+    sets.servoRollCenter = 1500;
+    sets.panMaxPulse = 2000;
+    sets.panMinPulse = 1000;
+    sets.tiltMaxPulse = 2000;
+    sets.tiltMinPulse = 1000;
+    sets.rollMaxPulse = 2000;
+    sets.rollMinPulse = 1000;
+    sets.panFactor = 17;
+    sets.tiltFactor = 17;
+    sets.rollFactor = 17;
+    sets.servoReverseMask = 0;
+
+    sets.accOffset[0] = sets.accOffset[1] = sets.accOffset[2] = 0;
+    sets.magOffset[0] = sets.magOffset[1] = sets.magOffset[2] = 0;
+    sets.gyroOff[0]   = sets.gyroOff[1]   = sets.gyroOff[2] = 0;
+
+    sets.htChannels[0] = 8; // pan
+    sets.htChannels[1] = 7; // tilt
+    sets.htChannels[2] = 6; // roll
+
+    sets.magGain[0]=sets.magGain[1]=sets.magGain[2]=1;
+    sets.accGain[0]=sets.accGain[1]=sets.accGain[2]=1;
+
+    byte i;
+    for(i=0; i<13; i++)
+	sets.PpmIn_PpmOut[i] = i;
+
+}
diff -BburpN DIY_Headtracker_Firmware_orig/DIY_headtracker/sensors.h DIY_Headtracker_Firmware_fastserial/DIY_headtracker/sensors.h
--- DIY_Headtracker_Firmware_orig/DIY_headtracker/sensors.h	2015-07-10 15:10:11.364406065 +0500
+++ DIY_Headtracker_Firmware_fastserial/DIY_headtracker/sensors.h	2017-05-28 16:56:44.024113709 +0500
@@ -6,10 +6,13 @@
 #define sensors_h
 
 #include "Arduino.h"
+#include "eeprom.h"
+
+extern byte compass;
 
 void InitSensors();
-void WriteToI2C(int device, byte address, byte val);
-void ReadFromI2C(int device, byte address, char bytesToRead);
+void WriteToI2C(byte device, byte address, byte val);
+void ReadFromI2C(byte device, byte address, byte bytesToRead);
 void UpdateSensors();
 void GyroCalc();
 void AccelCalc();
@@ -19,12 +22,14 @@ void SetGyroOffset();
 void testPanOutput();
 void trackerOutput();
 void calMagOutput();
+void getCompass();
 void calAccOutput(); 
 void calMagAccOutput(); // Output both mag and accel in one pass.
 void CalibrateMag();
 void FilterSensorData();
 void ResetCenter();
 void SensorInfoPrint();
+void CalibrateAccel();
 
 void testAllSensors();
 void testRollOutput();
@@ -32,5 +37,9 @@ void testAllData();
 void testAccOutput();
 void testGyroOutput();
 void testMagOutput();
+void CalcMagAngle();
+void clearSettings();
+void CalibrationStart();
 
 #endif // sensors_h
+
diff -BburpN DIY_Headtracker_Firmware_orig/HeadtrackerFirmware.vcxproj DIY_Headtracker_Firmware_fastserial/HeadtrackerFirmware.vcxproj
--- DIY_Headtracker_Firmware_orig/HeadtrackerFirmware.vcxproj	2013-04-27 09:26:56.000000000 +0600
+++ DIY_Headtracker_Firmware_fastserial/HeadtrackerFirmware.vcxproj	1970-01-01 05:00:00.000000000 +0500
@@ -1,77 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="DIY_headtracker\Config.h" />
-    <ClInclude Include="DIY_headtracker\Functions.h" />
-    <ClInclude Include="DIY_headtracker\Sensors.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="DIY_headtracker\DIY_headtracker.ino" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="DIY_headtracker\Functions.cpp" />
-    <ClCompile Include="DIY_headtracker\Sensors.cpp" />
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{6D743D35-01EE-4DE9-B19B-240CF3E146DA}</ProjectGuid>
-    <RootNamespace>HeadtrackerFirmware</RootNamespace>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>false</UseDebugLibraries>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup />
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-    </ClCompile>
-    <Link>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>MaxSpeed</Optimization>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-    </ClCompile>
-    <Link>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <OptimizeReferences>true</OptimizeReferences>
-    </Link>
-  </ItemDefinitionGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ В конце файла нет новой строки
diff -BburpN DIY_Headtracker_Firmware_orig/HeadtrackerFirmware.vcxproj.filters DIY_Headtracker_Firmware_fastserial/HeadtrackerFirmware.vcxproj.filters
--- DIY_Headtracker_Firmware_orig/HeadtrackerFirmware.vcxproj.filters	2013-04-26 14:44:22.000000000 +0600
+++ DIY_Headtracker_Firmware_fastserial/HeadtrackerFirmware.vcxproj.filters	1970-01-01 05:00:00.000000000 +0500
@@ -1,15 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <ClInclude Include="DIY_headtracker\config.h" />
-    <ClInclude Include="DIY_headtracker\functions.h" />
-    <ClInclude Include="DIY_headtracker\sensors.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="DIY_headtracker\functions.cpp" />
-    <ClCompile Include="DIY_headtracker\sensors.cpp" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="DIY_headtracker\DIY_headtracker.ino" />
-  </ItemGroup>
-</Project>
\ В конце файла нет новой строки
diff -BburpN DIY_Headtracker_Firmware_orig/HeadtrackerFirmware.vcxproj.user DIY_Headtracker_Firmware_fastserial/HeadtrackerFirmware.vcxproj.user
--- DIY_Headtracker_Firmware_orig/HeadtrackerFirmware.vcxproj.user	2013-03-13 21:27:50.000000000 +0600
+++ DIY_Headtracker_Firmware_fastserial/HeadtrackerFirmware.vcxproj.user	1970-01-01 05:00:00.000000000 +0500
@@ -1,3 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-</Project>
\ В конце файла нет новой строки
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/BetterStream.cpp DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/BetterStream.cpp
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/BetterStream.cpp	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/BetterStream.cpp	2016-04-18 12:42:18.122079181 +0500
@@ -0,0 +1,88 @@
+// -*- Mode: C++; c-basic-offset: 8; indent-tabs-mode: nil -*-
+//
+//      Copyright (c) 2010 Michael Smith. All rights reserved.
+//
+// This is free software; you can redistribute it and/or modify it under
+// the terms of the GNU Lesser General Public License as published by the
+// Free Software Foundation; either version 2.1 of the License, or (at
+// your option) any later version.
+//
+
+//
+// Enhancements to the Arduino Stream class.
+//
+
+//#include "SingleSerial.h"
+#define HardwareSerial_h
+#include <limits.h>
+#include "BetterStream.h"
+
+
+// prog_char_t is used as a wrapper type for prog_char, which is
+// a character stored in flash. By using this wrapper type we can
+// auto-detect at compile time if a call to a string function is using
+// a flash-stored string or not
+
+// Stream extensions////////////////////////////////////////////////////////////
+
+void
+BetterStream::print_P(const prog_char_t *s)
+{
+        char    c;
+
+        while ('\0' != (c = pgm_read_byte((const prog_char *)s++)))
+                _write(c);
+}
+
+void
+BetterStream::print_P(const prog_char *s)
+{
+        char    c;
+
+        while ('\0' != (c = pgm_read_byte((const prog_char *)s++)))
+                _write(c);
+}
+
+void
+BetterStream::println_P(const prog_char_t *s)
+{
+        print_P(s);
+        println();
+}
+
+void
+BetterStream::println_P(const prog_char *s)
+{
+        print_P(s);
+        println();
+}
+
+void
+BetterStream::printf(const char *fmt, ...)
+{
+        va_list ap;
+
+        va_start(ap, fmt);
+        _vprintf(0, fmt, ap);
+        va_end(ap);
+}
+
+void
+BetterStream::_printf_P(const prog_char *fmt, ...)
+{
+        va_list ap;
+
+        va_start(ap, fmt);
+        _vprintf(1, fmt, ap);
+        va_end(ap);
+}
+
+/*
+uint8_t
+BetterStream::txspace(void)
+{
+        // by default claim that there is always space in transmit buffer
+        return(255);
+}
+
+*/
\ В конце файла нет новой строки
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/BetterStream.h DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/BetterStream.h
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/BetterStream.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/BetterStream.h	2016-06-06 21:16:26.727799817 +0500
@@ -0,0 +1,56 @@
+// -*- Mode: C++; c-basic-offset: 8; indent-tabs-mode: nil -*-
+//
+//      Copyright (c) 2010 Michael Smith. All rights reserved.
+//
+// This is free software; you can redistribute it and/or modify it under
+// the terms of the GNU Lesser General Public License as published by the
+// Free Software Foundation; either version 2.1 of the License, or (at
+// your option) any later version.
+//
+
+#ifndef __BETTERSTREAM_H
+#define __BETTERSTREAM_H
+
+#define HardwareSerial_h
+
+
+//#define SKIP_FLOAT // printf without float
+
+#include "MyStream.h"
+#include <avr/pgmspace.h>
+
+// prog_char_t is used as a wrapper type for prog_char, which is
+// a character stored in flash. By using this wrapper type we can
+// auto-detect at compile time if a call to a string function is using
+// a flash-stored string or not
+typedef struct {
+    char c;
+} prog_char_t;
+typedef char prog_char;
+
+class BetterStream : public MyStream {
+public:
+        BetterStream(void) {
+        }
+
+        // Stream extensions
+        void            print_P(const prog_char_t *);
+        void            println_P(const prog_char_t *);
+        void            print_P(const prog_char *);
+        void            println_P(const prog_char *);
+        void            printf(const char *, ...)
+                __attribute__ ((format(__printf__, 2, 3)));
+        void            _printf_P(const prog_char *, ...);
+                __attribute__ ((format(__printf__, 2, 3)));
+
+//        virtual uint8_t     txspace(void);
+
+#define printf_P(fmt, ...) _printf_P((const prog_char *)fmt, ## __VA_ARGS__)
+
+private:
+        void            _vprintf(unsigned char, const char *, va_list)
+                __attribute__ ((format(__printf__, 3, 0)));
+};
+
+#endif // __BETTERSTREAM_H
+
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/examples/Makefile DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/examples/Makefile
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/examples/Makefile	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/examples/Makefile	2015-02-17 19:04:31.000000000 +0500
@@ -0,0 +1,2 @@
+BOARD	=	mega
+include ../../../AP_Common/Arduino.mk
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/examples/SingleSerial.pde DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/examples/SingleSerial.pde
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/examples/SingleSerial.pde	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/examples/SingleSerial.pde	2016-01-19 10:55:43.000000000 +0500
@@ -0,0 +1,67 @@
+// -*- Mode: C++; c-basic-offset: 8; indent-tabs-mode: nil -*-
+
+//
+// Example code for the SingleSerial driver.
+//
+// This code is placed into the public domain.
+//
+
+//
+// Include the SingleSerial library header.
+//
+// Note that this causes the standard Arduino Serial* driver to be
+// disabled.
+//
+#include <SingleSerial.h>
+
+#undef PROGMEM 
+#define PROGMEM __attribute__(( section(".progmem.data") )) 
+
+# undef PSTR
+# define PSTR(s) (__extension__({static prog_char __c[] PROGMEM = (s); \
+                (prog_char_t *)&__c[0];}))
+
+//
+// Create a SingleSerial driver that looks just like the stock Arduino
+// driver.
+//
+SingleSerialPort(Serial);
+
+
+void setup(void)
+{
+        //
+        // Set the speed for our replacement serial port.
+        //
+	Serial.begin(115200);
+
+        //
+        // Test printing things
+        //
+        Serial.print("test");
+        Serial.println(" begin");
+        Serial.println(1000);
+        Serial.println(1000, 8);
+        Serial.println(1000, 10);
+        Serial.println(1000, 16);
+        Serial.println_P(PSTR("progmem"));
+        Serial.printf("printf %d %u %#x %p %f %S\n", -1000, 1000, 1000, 1000, 1.2345, PSTR("progmem"));
+        Serial.printf_P(PSTR("printf_P %d %u %#x %p %f %S\n"), -1000, 1000, 1000, 1000, 1.2345, PSTR("progmem"));
+        Serial.println("done");
+}
+
+void
+loop(void)
+{
+    int    c;
+
+    //
+    // Perform a simple loopback operation.
+    //
+    
+    if(Serial.available()) {
+	c = Serial.read();
+        Serial.write(c);
+    }
+}
+
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/ftoa_engine.h DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/ftoa_engine.h
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/ftoa_engine.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/ftoa_engine.h	2015-02-17 19:04:31.000000000 +0500
@@ -0,0 +1,48 @@
+/* Copyright (c) 2005, Dmitry Xmelkov
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: ftoa_engine.h 1218 2007-02-18 13:18:41Z dmix $ */
+
+#ifndef	_FTOA_ENGINE_H
+#define	_FTOA_ENGINE_H
+
+#ifndef	__ASSEMBLER__
+
+int __ftoa_engine (double val, char *buf,
+                   unsigned char prec, unsigned char maxdgs);
+
+#endif
+
+/* '__ftoa_engine' return next flags (in buf[0]):	*/
+#define	FTOA_MINUS	1
+#define	FTOA_ZERO	2
+#define	FTOA_INF	4
+#define	FTOA_NAN	8
+#define	FTOA_CARRY	16	/* Carry was to master position.	*/
+
+#endif	/* !_FTOA_ENGINE_H */
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/ftoa_engine.S DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/ftoa_engine.S
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/ftoa_engine.S	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/ftoa_engine.S	2015-02-17 19:04:31.000000000 +0500
@@ -0,0 +1,532 @@
+/* Copyright (c) 2005, Dmitry Xmelkov
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: ftoa_engine.S,v 1.3 2009/04/01 23:11:00 arcanum Exp $ */
+
+#ifndef	__DOXYGEN__
+
+#include "macros.inc"
+#include "ftoa_engine.h"
+
+#if  defined(__AVR_HAVE_LPMX__) && __AVR_HAVE_LPMX__
+#  define AVR_ENH_LPM	1
+#else
+#  define AVR_ENH_LPM	0
+#endif
+
+/*
+   int __ftoa_engine (double val, char *buf,
+                      unsigned char prec, unsigned char maxdgs)
+ Input:
+    val    - value to convert
+    buf    - output buffer address
+    prec   - precision: number of decimal digits is 'prec + 1'
+    maxdgs - (0 if unused) precision restriction for "%f" specification
+
+ Output:
+    return     - decimal exponent of first digit
+    buf[0]     - flags (FTOA_***)
+    buf[1],... - decimal digits
+    Number of digits:
+	maxdgs == 0 ? prec+1 :
+	(buf[0] & FTOA_CARRY) == 0 || buf[1] != '1' ?
+	    aver(1, maxdgs+exp, prec+1) :
+	    aver(1, masdgs+exp-1, prec+1)
+
+ Notes:
+    * Output string is not 0-terminated. For possibility of user's buffer
+    usage in any case.
+    * If used, 'maxdgs' is a number of digits for value with zero exponent.
+*/
+
+    /* Input */
+#define maxdgs	r16
+#define	prec	r18
+#define	buf_lo	r20
+#define	buf_hi	r21
+#define	val_lo	r22
+#define	val_hi	r23
+#define	val_hlo	r24
+#define	val_hhi	r25
+
+    /* Float value parse	*/
+#define	flag	r19
+
+    /* Multiplication of mantisses	*/
+#define	exp_sv	r17
+#define	mlt_1	r19	/* lowest result byte	*/
+#define mlt_2	r14
+#define	mlt_3	r15
+#define	mlt_4	r20
+#define	mlt_5	r21
+#define	mlt_6	r28
+#define	mlt_7	r29
+
+    /* Conversion to string	*/
+#define	pwr_2	r1	/* lowest byte of 'powr10' element	*/
+#define	pwr_3	r17
+#define	pwr_4	r19
+#define	pwr_5	r22
+#define	pwr_6	r25
+#define	pwr_7	r0
+#define	digit	r23
+#define	exp10	r24
+
+    /* Fixed */
+#define	zero	r1
+
+/*    ASSEMBLY_CLIB_SECTION */
+	
+    .global	__ftoa_engine
+    .type	__ftoa_engine, "function"
+__ftoa_engine:
+
+/* --------------------------------------------------------------------
+   Float value parse.
+*/
+  ; limit 'prec'
+	cpi	prec, 8
+	brlo	1f
+	ldi	prec, 7
+1:
+  ; init.
+	clr	flag
+	X_movw	XL, buf_lo
+  ; val_hhi := exponent, sign test and remove
+#if  FTOA_MINUS != 1
+#  error  FTOA_MINUS must be 1:  add with carry used
+#endif
+	lsl	val_hhi
+	adc	flag, zero		; FTOA_MINUS
+	sbrc	val_hlo, 7
+	ori	val_hhi, 1
+  ; zero test
+	adiw	val_hlo, 0
+	cpc	val_lo, zero
+	cpc	val_hi, zero
+	brne	3f
+  ; return 0
+	ori	flag, FTOA_ZERO
+	subi	prec, -2
+2:	st	X+, flag
+	ldi	flag, '0'
+	dec	prec
+	brne	2b
+	ret				; r24,r25 == 0
+3:
+  ; infinity, NaN ?
+#if  FTOA_NAN != 2 * FTOA_INF
+#  error  Must: FTOA_NAN == 2*FTOA_INF: 'rjmp' is absent
+#endif
+	cpi	val_hhi, 0xff
+	brlo	6f
+	cpi	val_hlo, 0x80
+	cpc	val_hi, zero
+	cpc	val_lo, zero
+	breq	5f
+	subi	flag, -FTOA_INF		; FTOA_NAN
+5:	subi	flag, -FTOA_INF
+6:
+  ; write flags byte
+	st	X+, flag
+  ; hidden bit
+	cpi	val_hhi, 1
+	brlo	7f			; if subnormal value
+	ori	val_hlo, 0x80
+7:	adc	val_hhi, zero
+  ; pushes
+	push	r29
+	push	r28
+	push	r17
+	push	r16
+	push	r15
+	push	r14
+
+/* --------------------------------------------------------------------
+   Multiplication of mantisses (val and table).
+   At the begin:
+	val_hlo .. val_lo  - input value mantisse
+	val_hhi            - input value exponent
+	X                  - second byte address (string begin)
+   At the end:
+	mlt_7 .. mlt_2     - multiplication result
+	exp10              - decimal exponent
+*/
+
+  ; save
+	mov	exp_sv, val_hhi
+  ; Z := & base10[exp / 8]	(sizeof(base10[0]) == 5)
+	andi	val_hhi, ~7
+	lsr	val_hhi			; (exp/8) * 4
+	mov	ZL, val_hhi
+	lsr	val_hhi
+	lsr	val_hhi			; exp/8
+	add	ZL, val_hhi		; (exp/8) * 5
+	clr	ZH
+	subi	ZL, lo8(-(.L_base10))
+	sbci	ZH, hi8(-(.L_base10))
+  ; highest mantissa byte  (mult. shifting prepare)
+	clr	val_hhi
+  ; result initializ.
+	clr	mlt_1
+	clr	mlt_2
+	clr	mlt_3
+	X_movw	mlt_4, mlt_2
+	X_movw	mlt_6, mlt_2
+
+  ; multiply to 1-st table byte
+#if  AVR_ENH_LPM
+	lpm	r0, Z+
+#else
+	lpm
+	adiw	ZL, 1
+#endif
+	sec			; for loop end control
+	ror	r0
+  ; addition
+10:	brcc	11f
+	add	mlt_1, val_lo
+	adc	mlt_2, val_hi
+	adc	mlt_3, val_hlo
+	adc	mlt_4, val_hhi
+	adc	mlt_5, zero
+  ; arg shift
+11:	lsl	val_lo
+	rol	val_hi
+	rol	val_hlo
+	rol	val_hhi
+  ; next bit
+	lsr	r0
+	brne	10b
+
+  ; second table byte
+#if  AVR_ENH_LPM
+	lpm	r0, Z+		; C flag is stay 1
+#else
+	lpm
+	adiw	ZL, 1
+	sec
+#endif
+	ror	r0
+  ; addition
+12:	brcc	13f
+	add	mlt_2, val_hi		; val_hi is the least byte now
+	adc	mlt_3, val_hlo
+	adc	mlt_4, val_hhi
+	adc	mlt_5, val_lo
+	adc	mlt_6, zero
+  ; arg shift
+13:	lsl	val_hi
+	rol	val_hlo
+	rol	val_hhi
+	rol	val_lo
+  ; next bit
+	lsr	r0
+	brne	12b
+
+  ; 3-t table byte
+#if  AVR_ENH_LPM
+	lpm	r0, Z+		; C flag is stay 1
+#else
+	lpm
+	adiw	ZL, 1
+	sec
+#endif
+	ror	r0
+  ; addition
+14:	brcc	15f
+	add	mlt_3, val_hlo		; val_hlo is the least byte now
+	adc	mlt_4, val_hhi
+	adc	mlt_5, val_lo
+	adc	mlt_6, val_hi
+	adc	mlt_7, zero
+  ; arg shift
+15:	lsl	val_hlo
+	rol	val_hhi
+	rol	val_lo
+	rol	val_hi
+  ; next bit
+	lsr	r0
+	brne	14b
+
+  ; 4-t table byte
+#if  AVR_ENH_LPM
+	lpm	r0, Z+		; C flag is stay 1
+#else
+	lpm
+#endif
+	ror	r0
+  ; addition
+16:	brcc	17f
+	add	mlt_4, val_hhi		; val_hhi is the least byte now
+	adc	mlt_5, val_lo
+	adc	mlt_6, val_hi
+	adc	mlt_7, val_hlo
+  ; arg shift
+17:	lsl	val_hhi
+	rol	val_lo
+	rol	val_hi
+	rol	val_hlo
+  ; next bit
+	lsr	r0
+	brne	16b
+
+  ; decimal exponent
+#if  AVR_ENH_LPM
+	lpm	exp10, Z
+#else
+	adiw	ZL, 1
+	lpm
+	mov	exp10, r0
+#endif
+
+  ; result shift:  mlt_7..2 >>= (~exp & 7)
+	com	exp_sv
+	andi	exp_sv, 7
+	breq	19f
+18:	lsr	mlt_7
+	ror	mlt_6
+	ror	mlt_5
+	ror	mlt_4
+	ror	mlt_3
+	ror	mlt_2
+	dec	exp_sv
+	brne	18b
+19:
+
+/* --------------------------------------------------------------------
+   Conversion to string.
+
+   Registers usage:
+      mlt_7 .. mlt_2	- new mantissa (multiplication result)
+      pwr_7 .. pwr_2	- 'powr10' table element
+      Z			- 'powr10' table pointer
+      X			- output string pointer
+      maxdgs		- number of digits
+      prec		- number of digits stays to output
+      exp10		- decimal exponent
+      digit		- conversion process
+
+   At the end:
+      X			- end of buffer (nonfilled byte)
+      exp10		- corrected dec. exponent
+      mlt_7 .. mlt_2	- remainder
+      pwr_7 .. pwr_2	- last powr10[] element
+
+   Notes:
+     * It is possible to leave out powr10'x table with subnormal value.
+      Result: accuracy degrease on the rounding phase.  No matter: high
+      precision with subnormals is not needed. (Now 0x00000001 is converted
+      exactly on prec = 5, i.e. 6 digits.)
+*/
+
+  ; to find first digit
+	ldi	ZL, lo8(.L_powr10)
+	ldi	ZH, hi8(.L_powr10)
+	set
+  ; 'pwr10' element reading
+.L_digit:
+	X_lpm	pwr_2, Z+
+	X_lpm	pwr_3, Z+
+	X_lpm	pwr_4, Z+
+	X_lpm	pwr_5, Z+
+	X_lpm	pwr_6, Z+
+	X_lpm	pwr_7, Z+
+  ; 'digit' init.
+	ldi	digit, '0' - 1
+  ; subtraction loop
+20:	inc	digit
+	sub	mlt_2, pwr_2
+	sbc	mlt_3, pwr_3
+	sbc	mlt_4, pwr_4
+	sbc	mlt_5, pwr_5
+	sbc	mlt_6, pwr_6
+	sbc	mlt_7, pwr_7
+	brsh	20b
+  ; restore mult
+	add	mlt_2, pwr_2
+	adc	mlt_3, pwr_3
+	adc	mlt_4, pwr_4
+	adc	mlt_5, pwr_5
+	adc	mlt_6, pwr_6
+	adc	mlt_7, pwr_7
+  ; analisys
+	brtc	25f
+	cpi	digit, '0'
+	brne	21f		; this is the first digit finded
+	dec	exp10
+	rjmp	.L_digit
+  ; now is the first digit
+21:	clt
+  ; number of digits
+	subi	maxdgs, 1
+	brlo	23f			; maxdgs was 0
+	add	maxdgs, exp10
+	brpl	22f
+	clr	maxdgs
+22:	cp	maxdgs, prec
+	brsh	23f
+	mov	prec, maxdgs
+23:	inc	prec
+	mov	maxdgs, prec	
+  ; operate digit
+25:	cpi	digit, '0' + 10
+	brlo	27f
+  ; overflow, digit > '9'
+	ldi	digit, '9'
+26:	st	X+, digit
+	dec	prec
+	brne	26b
+	rjmp	.L_up
+  ; write digit
+27:	st	X+, digit
+	dec	prec
+	brne	.L_digit
+
+/* --------------------------------------------------------------------
+    Rounding.
+*/
+.L_round:
+  ; pwr10 /= 2
+	lsr	pwr_7
+	ror	pwr_6
+	ror	pwr_5
+	ror	pwr_4
+	ror	pwr_3
+	ror	pwr_2
+  ; mult -= pwr10  (half of last 'pwr10' value)
+	sub	mlt_2, pwr_2
+	sbc	mlt_3, pwr_3
+	sbc	mlt_4, pwr_4
+	sbc	mlt_5, pwr_5
+	sbc	mlt_6, pwr_6
+	sbc	mlt_7, pwr_7
+  ; rounding direction?
+	brlo	.L_rest
+  ; round to up
+.L_up:
+	inc	prec
+	ld	digit, -X
+	inc	digit
+	cpi	digit, '9' + 1
+	brlo	31f
+	ldi	digit, '0'
+31:	st	X, digit
+	cpse	prec, maxdgs
+	brsh	.L_up
+  ; it was a carry to master digit
+	ld	digit, -X		; flags
+	ori	digit, FTOA_CARRY	; 'C' is not changed
+	st	X+, digit
+	brlo	.L_rest			; above comparison
+  ; overflow
+	inc	exp10
+	ldi	digit, '1'
+32:	st	X+, digit
+	ldi	digit, '0'
+	dec	prec
+	brne	32b
+  ; restore
+.L_rest:
+	clr	zero
+	pop	r14
+	pop	r15
+	pop	r16
+	pop	r17
+	pop	r28
+	pop	r29
+  ; return
+	clr	r25
+	sbrc	exp10, 7		; high byte
+	com	r25
+	ret
+
+    .size  __ftoa_engine, . - __ftoa_engine
+
+/* --------------------------------------------------------------------
+    Tables.  '.L_powr10' is placed first -- for subnormals stability.
+*/
+    .section .progmem.data,"a",@progbits
+
+    .type .L_powr10, "object"
+.L_powr10:
+	.byte	0, 64, 122, 16, 243, 90	; 100000000000000
+	.byte	0, 160, 114, 78, 24, 9	; 10000000000000
+	.byte	0, 16, 165, 212, 232, 0	; 1000000000000
+	.byte	0, 232, 118, 72, 23, 0	; 100000000000
+	.byte	0, 228, 11, 84, 2, 0	; 10000000000
+	.byte	0, 202, 154, 59, 0, 0	; 1000000000
+	.byte	0, 225, 245, 5, 0, 0	; 100000000
+	.byte	128, 150, 152, 0, 0, 0	; 10000000
+	.byte	64, 66, 15, 0, 0, 0	; 1000000
+	.byte	160, 134, 1, 0, 0, 0	; 100000
+	.byte	16, 39, 0, 0, 0, 0	; 10000
+	.byte	232, 3, 0, 0, 0, 0	; 1000
+	.byte	100, 0, 0, 0, 0, 0	; 100
+	.byte	10, 0, 0, 0, 0, 0	; 10
+	.byte	1, 0, 0, 0, 0, 0	; 1
+    .size .L_powr10, . - .L_powr10
+
+    .type	.L_base10, "object"
+.L_base10:
+	.byte	44, 118, 216, 136, -36	; 2295887404
+	.byte	103, 79, 8, 35, -33	; 587747175
+	.byte	193, 223, 174, 89, -31	; 1504632769
+	.byte	177, 183, 150, 229, -29	; 3851859889
+	.byte	228, 83, 198, 58, -26	; 986076132
+	.byte	81, 153, 118, 150, -24	; 2524354897
+	.byte	230, 194, 132, 38, -21	; 646234854
+	.byte	137, 140, 155, 98, -19	; 1654361225
+	.byte	64, 124, 111, 252, -17	; 4235164736
+	.byte	188, 156, 159, 64, -14	; 1084202172
+	.byte	186, 165, 111, 165, -12	; 2775557562
+	.byte	144, 5, 90, 42, -9	; 710542736
+	.byte	92, 147, 107, 108, -7	; 1818989404
+	.byte	103, 109, 193, 27, -4	; 465661287
+	.byte	224, 228, 13, 71, -2	; 1192092896
+	.byte	245, 32, 230, 181, 0	; 3051757813
+	.byte	208, 237, 144, 46, 3	; 781250000
+	.byte	0, 148, 53, 119, 5	; 2000000000
+	.byte	0, 128, 132, 30, 8	; 512000000
+	.byte	0, 0, 32, 78, 10	; 1310720000
+	.byte	0, 0, 0, 200, 12	; 3355443200
+	.byte	51, 51, 51, 51, 15	; 858993459
+	.byte	152, 110, 18, 131, 17	; 2199023256
+	.byte	65, 239, 141, 33, 20	; 562949953
+	.byte	137, 59, 230, 85, 22	; 1441151881
+	.byte	207, 254, 230, 219, 24	; 3689348815
+	.byte	209, 132, 75, 56, 27	; 944473297
+	.byte	247, 124, 29, 144, 29	; 2417851639
+	.byte	164, 187, 228, 36, 32	; 618970020
+	.byte	50, 132, 114, 94, 34	; 1584563250
+	.byte	129, 0, 201, 241, 36	; 4056481921
+	.byte	236, 161, 229, 61, 39	; 1038459372
+    .size .L_base10, . - .L_base10
+
+	.end
+#endif	/* !__DOXYGEN__ */
\ В конце файла нет новой строки
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/COMMIT_EDITMSG DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/COMMIT_EDITMSG
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/COMMIT_EDITMSG	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/COMMIT_EDITMSG	2016-02-23 18:35:54.000000000 +0500
@@ -0,0 +1,12 @@
+turn off SKIP_FLOAT
+
+# Please enter the commit message for your changes. Lines starting
+# with '#' will be ignored, and an empty message aborts the commit.
+# On branch master
+# Your branch is up-to-date with 'origin/master'.
+#
+# Changes to be committed:
+#	modified:   BetterStream.h
+#	modified:   SingleSerial.cpp
+#	modified:   SingleSerial.h
+#
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/config DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/config
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/config	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/config	2015-12-30 16:49:15.000000000 +0500
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = git+ssh://git@github.com/night-ghost/SingleSerial.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/description DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/description
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/description	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/description	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/FETCH_HEAD DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/FETCH_HEAD
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/FETCH_HEAD	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/FETCH_HEAD	2016-03-30 10:17:47.052404136 +0500
@@ -0,0 +1 @@
+75c230f5ada31a4a8000465de6ac2eea5c27f076		branch 'master' of git+ssh://github.com/night-ghost/SingleSerial
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/HEAD DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/HEAD
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/HEAD	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/HEAD	2015-12-30 15:04:18.000000000 +0500
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/applypatch-msg.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/applypatch-msg.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/applypatch-msg.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/applypatch-msg.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/commit-msg" &&
+	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+:
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/commit-msg.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/commit-msg.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/commit-msg.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/commit-msg.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/post-update.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/post-update.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/post-update.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/post-update.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/pre-applypatch.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/pre-applypatch.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/pre-applypatch.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/pre-applypatch.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+:
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/pre-commit.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/pre-commit.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/pre-commit.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/pre-commit.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/prepare-commit-msg.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/prepare-commit-msg.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/prepare-commit-msg.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/prepare-commit-msg.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/pre-push.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/pre-push.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/pre-push.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/pre-push.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,54 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+IFS=' '
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/pre-rebase.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/pre-rebase.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/pre-rebase.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/pre-rebase.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+exit 0
+
+################################################################
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/update.sample DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/update.sample
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/hooks/update.sample	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/hooks/update.sample	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to blocks unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/index and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/index differ
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/info/exclude DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/info/exclude
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/info/exclude	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/info/exclude	2015-12-30 15:04:17.000000000 +0500
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/logs/HEAD DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/logs/HEAD
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/logs/HEAD	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/logs/HEAD	2016-02-23 18:35:55.000000000 +0500
@@ -0,0 +1,7 @@
+0000000000000000000000000000000000000000 5d2ece66c2a57d90be9c71426d981cd72778746f night-ghost <night_ghost@ykoctpa.ru> 1451469858 +0500	clone: from https://github.com/night-ghost/SingleSerial.git
+5d2ece66c2a57d90be9c71426d981cd72778746f 0f8d41e538f8c913a4f3b1b2baed3a01fffbc710 night-ghost <night_ghost@ykoctpa.ru> 1451476162 +0500	commit: first release
+0f8d41e538f8c913a4f3b1b2baed3a01fffbc710 01c997a43742dd8e9d706499d8b3aed5e4bb76ad night-ghost <night_ghost@ykoctpa.ru> 1453182573 +0500	commit: corrected some sizes of variables
+01c997a43742dd8e9d706499d8b3aed5e4bb76ad 53aaccab1b791d5c5b686109d7d6bde6ad56bd16 night-ghost <night_ghost@ykoctpa.ru> 1453182973 +0500	commit: corrected sample
+53aaccab1b791d5c5b686109d7d6bde6ad56bd16 76f48c14c94c758f89924d8c761aa7e2388986b1 night-ghost <night_ghost@ykoctpa.ru> 1454066356 +0500	commit: return value of _write()
+76f48c14c94c758f89924d8c761aa7e2388986b1 aaff3adea85b6b831a136f367d8e34431e85a8df night-ghost <night_ghost@ykoctpa.ru> 1456153504 +0500	commit: fixed bug with MAVlink
+aaff3adea85b6b831a136f367d8e34431e85a8df 11023f27c9d130c8d46a0c8a15d491fe10c3a273 night-ghost <night_ghost@ykoctpa.ru> 1456234540 +0500	commit: turn off SKIP_FLOAT
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/logs/refs/heads/master DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/logs/refs/heads/master
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/logs/refs/heads/master	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/logs/refs/heads/master	2016-02-23 18:35:55.000000000 +0500
@@ -0,0 +1,7 @@
+0000000000000000000000000000000000000000 5d2ece66c2a57d90be9c71426d981cd72778746f night-ghost <night_ghost@ykoctpa.ru> 1451469858 +0500	clone: from https://github.com/night-ghost/SingleSerial.git
+5d2ece66c2a57d90be9c71426d981cd72778746f 0f8d41e538f8c913a4f3b1b2baed3a01fffbc710 night-ghost <night_ghost@ykoctpa.ru> 1451476162 +0500	commit: first release
+0f8d41e538f8c913a4f3b1b2baed3a01fffbc710 01c997a43742dd8e9d706499d8b3aed5e4bb76ad night-ghost <night_ghost@ykoctpa.ru> 1453182573 +0500	commit: corrected some sizes of variables
+01c997a43742dd8e9d706499d8b3aed5e4bb76ad 53aaccab1b791d5c5b686109d7d6bde6ad56bd16 night-ghost <night_ghost@ykoctpa.ru> 1453182973 +0500	commit: corrected sample
+53aaccab1b791d5c5b686109d7d6bde6ad56bd16 76f48c14c94c758f89924d8c761aa7e2388986b1 night-ghost <night_ghost@ykoctpa.ru> 1454066356 +0500	commit: return value of _write()
+76f48c14c94c758f89924d8c761aa7e2388986b1 aaff3adea85b6b831a136f367d8e34431e85a8df night-ghost <night_ghost@ykoctpa.ru> 1456153504 +0500	commit: fixed bug with MAVlink
+aaff3adea85b6b831a136f367d8e34431e85a8df 11023f27c9d130c8d46a0c8a15d491fe10c3a273 night-ghost <night_ghost@ykoctpa.ru> 1456234540 +0500	commit: turn off SKIP_FLOAT
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/logs/refs/remotes/origin/HEAD DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/logs/refs/remotes/origin/HEAD
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/logs/refs/remotes/origin/HEAD	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/logs/refs/remotes/origin/HEAD	2015-12-30 15:04:18.000000000 +0500
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 5d2ece66c2a57d90be9c71426d981cd72778746f night-ghost <night_ghost@ykoctpa.ru> 1451469858 +0500	clone: from https://github.com/night-ghost/SingleSerial.git
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/logs/refs/remotes/origin/master DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/logs/refs/remotes/origin/master
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/logs/refs/remotes/origin/master	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/logs/refs/remotes/origin/master	2016-03-30 10:17:46.981403985 +0500
@@ -0,0 +1,7 @@
+5d2ece66c2a57d90be9c71426d981cd72778746f 0f8d41e538f8c913a4f3b1b2baed3a01fffbc710 night-ghost <night_ghost@ykoctpa.ru> 1451476181 +0500	update by push
+0f8d41e538f8c913a4f3b1b2baed3a01fffbc710 01c997a43742dd8e9d706499d8b3aed5e4bb76ad night-ghost <night_ghost@ykoctpa.ru> 1453182645 +0500	update by push
+01c997a43742dd8e9d706499d8b3aed5e4bb76ad 53aaccab1b791d5c5b686109d7d6bde6ad56bd16 night-ghost <night_ghost@ykoctpa.ru> 1453182991 +0500	update by push
+53aaccab1b791d5c5b686109d7d6bde6ad56bd16 76f48c14c94c758f89924d8c761aa7e2388986b1 night-ghost <night_ghost@ykoctpa.ru> 1454066391 +0500	update by push
+76f48c14c94c758f89924d8c761aa7e2388986b1 aaff3adea85b6b831a136f367d8e34431e85a8df night-ghost <night_ghost@ykoctpa.ru> 1456153528 +0500	update by push
+aaff3adea85b6b831a136f367d8e34431e85a8df 11023f27c9d130c8d46a0c8a15d491fe10c3a273 night-ghost <night_ghost@ykoctpa.ru> 1456234563 +0500	update by push
+11023f27c9d130c8d46a0c8a15d491fe10c3a273 75c230f5ada31a4a8000465de6ac2eea5c27f076 night-ghost <night_ghost@ykoctpa.ru> 1459315066 +0500	pull: fast-forward
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/01/c997a43742dd8e9d706499d8b3aed5e4bb76ad and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/01/c997a43742dd8e9d706499d8b3aed5e4bb76ad differ
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/0f/8d41e538f8c913a4f3b1b2baed3a01fffbc710 DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/0f/8d41e538f8c913a4f3b1b2baed3a01fffbc710
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/0f/8d41e538f8c913a4f3b1b2baed3a01fffbc710	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/0f/8d41e538f8c913a4f3b1b2baed3a01fffbc710	2015-12-30 16:49:36.000000000 +0500
@@ -0,0 +1,2 @@
+xM
+0F]ًLDL-t-={qǡjhܩHkZNw#@ S.4֢ZTO Q#L'!u)6&f[碧˫תo<x|s_vy->oGe}~BK.
\ В конце файла нет новой строки
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/11/023f27c9d130c8d46a0c8a15d491fe10c3a273 DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/11/023f27c9d130c8d46a0c8a15d491fe10c3a273
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/11/023f27c9d130c8d46a0c8a15d491fe10c3a273	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/11/023f27c9d130c8d46a0c8a15d491fe10c3a273	2016-02-23 18:35:55.000000000 +0500
@@ -0,0 +1 @@
+xJ1ayL	A^fLnJ=nI}^+Tr%FFTx$ٜ01zd,\*G?)0X="W[t8?݆Æ۹es_0ɓG5yh"}xz5wM{
\ В конце файла нет новой строки
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/15/d41dfbf0e61e391bc39b8d52eeb5ccfbfc9b2c and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/15/d41dfbf0e61e391bc39b8d52eeb5ccfbfc9b2c differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/1d/5eb3b15e243e12aac5fb0e02f3295a57cec25e and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/1d/5eb3b15e243e12aac5fb0e02f3295a57cec25e differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/20/388ab9fa74573d349eddc917166a17828548d1 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/20/388ab9fa74573d349eddc917166a17828548d1 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/21/b1e2157b49ddf0abee3f4d0b495f2351cfaf77 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/21/b1e2157b49ddf0abee3f4d0b495f2351cfaf77 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/26/7795438adf10a2340eda6029a872f7f7b93116 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/26/7795438adf10a2340eda6029a872f7f7b93116 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/27/a96aa72664012713f0e35357ca89ce2ebcf9d6 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/27/a96aa72664012713f0e35357ca89ce2ebcf9d6 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/2a/9863ff94e6c34adbde591d93d8ae3650e5377e and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/2a/9863ff94e6c34adbde591d93d8ae3650e5377e differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/31/967362afcdbb67dc72bdb3e42090ace29a5dad and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/31/967362afcdbb67dc72bdb3e42090ace29a5dad differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/34/bd0a4122ba7eeaea588f36f873660b899c99e7 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/34/bd0a4122ba7eeaea588f36f873660b899c99e7 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/3e/65c7a40501a5b4fc94ab93c75763235d268d9c and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/3e/65c7a40501a5b4fc94ab93c75763235d268d9c differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/46/2c2fa5af5ff6c7a14ebc312120d7a4ddd60e58 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/46/2c2fa5af5ff6c7a14ebc312120d7a4ddd60e58 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/48/208e1391e970e1d7f98f21af396c7ba3cbb50e and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/48/208e1391e970e1d7f98f21af396c7ba3cbb50e differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/4a/fde5e236d30288f58284a7e0d21d783f7a5dd9 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/4a/fde5e236d30288f58284a7e0d21d783f7a5dd9 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/4d/947d9aa93a47ab3b5c245edb7ff95bd5fbd767 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/4d/947d9aa93a47ab3b5c245edb7ff95bd5fbd767 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/52/8dc4d7bd447ca634881e7e35bd81dd46eb5e5c and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/52/8dc4d7bd447ca634881e7e35bd81dd46eb5e5c differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/53/aaccab1b791d5c5b686109d7d6bde6ad56bd16 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/53/aaccab1b791d5c5b686109d7d6bde6ad56bd16 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/58/1a494bf54c86d13479e1976d5289c9b8d94025 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/58/1a494bf54c86d13479e1976d5289c9b8d94025 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/59/7f8e1c8dc1de05d715e97a07ae81a2d82c9b9f and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/59/7f8e1c8dc1de05d715e97a07ae81a2d82c9b9f differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/5d/2ece66c2a57d90be9c71426d981cd72778746f and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/5d/2ece66c2a57d90be9c71426d981cd72778746f differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/63/e56d75099b35dd6fa77e592dc4ad4863d6bde6 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/63/e56d75099b35dd6fa77e592dc4ad4863d6bde6 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/6a/a0a65c3f4a20b019f3fa6e62976267c912c135 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/6a/a0a65c3f4a20b019f3fa6e62976267c912c135 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/70/926b1a35c7266dbbdbc6749d7bba2fa06a8e14 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/70/926b1a35c7266dbbdbc6749d7bba2fa06a8e14 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/75/c230f5ada31a4a8000465de6ac2eea5c27f076 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/75/c230f5ada31a4a8000465de6ac2eea5c27f076 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/76/f48c14c94c758f89924d8c761aa7e2388986b1 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/76/f48c14c94c758f89924d8c761aa7e2388986b1 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/78/a63132e9c5f5f403844a26a125531dcc32daee and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/78/a63132e9c5f5f403844a26a125531dcc32daee differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/7e/6973b647d34f814a3b6732333e4ed1766fb8dc and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/7e/6973b647d34f814a3b6732333e4ed1766fb8dc differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/7f/421e652adef0a502087b65c5e67477cbe4d029 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/7f/421e652adef0a502087b65c5e67477cbe4d029 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/86/a02342a443c8f8ccb44b90689f19585e4275e6 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/86/a02342a443c8f8ccb44b90689f19585e4275e6 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/89/38454d3cf47853dcf9850aaa75ca6ba6d0806b and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/89/38454d3cf47853dcf9850aaa75ca6ba6d0806b differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/90/d481214ec688966174bc8af785b5cd6d9a5623 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/90/d481214ec688966174bc8af785b5cd6d9a5623 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/91/204eca5489b1f5b5aa14edc0c6ab644a79d29e and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/91/204eca5489b1f5b5aa14edc0c6ab644a79d29e differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/92/7023cac5db58502440937602f38c362130b98e and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/92/7023cac5db58502440937602f38c362130b98e differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/96/f35472dcac2d855f976e9eb1de641dc6470c87 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/96/f35472dcac2d855f976e9eb1de641dc6470c87 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/97/c6cfe466d7a9bad8a9023b91105d376a9698e1 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/97/c6cfe466d7a9bad8a9023b91105d376a9698e1 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/9b/5c00f21028e9a02953ad48ccf562d6434c6ef5 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/9b/5c00f21028e9a02953ad48ccf562d6434c6ef5 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/9d/65223551fc73bb3555f221cc6fcbd716ab1339 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/9d/65223551fc73bb3555f221cc6fcbd716ab1339 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/a1/6dcc52d36c612b2245f4277154cfda393980bd and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/a1/6dcc52d36c612b2245f4277154cfda393980bd differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/aa/ff3adea85b6b831a136f367d8e34431e85a8df and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/aa/ff3adea85b6b831a136f367d8e34431e85a8df differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/b1/6b8cbfa95e25698b1deaea91f3dd1077cbc10c and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/b1/6b8cbfa95e25698b1deaea91f3dd1077cbc10c differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/b2/9440c4515ab9334507f0874ad69d9536d804d6 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/b2/9440c4515ab9334507f0874ad69d9536d804d6 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/b9/3dd4a53069e332ee97d6c6b9ba716761895d2c and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/b9/3dd4a53069e332ee97d6c6b9ba716761895d2c differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/bb/5f47657f50f2e42952b94ccfd6ef81610ecacf and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/bb/5f47657f50f2e42952b94ccfd6ef81610ecacf differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/c3/73e7fd76533b49ad5ef10918e7f32dacd51bc6 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/c3/73e7fd76533b49ad5ef10918e7f32dacd51bc6 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/ce/591ef1b56e86b0eaf1d588013ef74ee0ccea12 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/ce/591ef1b56e86b0eaf1d588013ef74ee0ccea12 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/d2/faf40eb36a499a2622ebf0f14bea7a79dbc39c and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/d2/faf40eb36a499a2622ebf0f14bea7a79dbc39c differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/d4/6adbff92e2fca1027cfe927fb9253a82e61af2 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/d4/6adbff92e2fca1027cfe927fb9253a82e61af2 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/d5/c1910428e27dacf427f11a6f61f3e32c609a90 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/d5/c1910428e27dacf427f11a6f61f3e32c609a90 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/d6/4e8e129b905641990499d4b9693c47e761f499 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/d6/4e8e129b905641990499d4b9693c47e761f499 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/dc/cf84b68ecd1f37e5e8cf3b630924b1ad71fb77 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/dc/cf84b68ecd1f37e5e8cf3b630924b1ad71fb77 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/e2/2ce4597fb7439da74d2f90c9396fc885586a69 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/e2/2ce4597fb7439da74d2f90c9396fc885586a69 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/e6/a39be9a2829e87afd5b5042b13d52d2aaaf042 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/e6/a39be9a2829e87afd5b5042b13d52d2aaaf042 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/e6/f0c534a8e54192b414512db602b2c29add13dc and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/e6/f0c534a8e54192b414512db602b2c29add13dc differ
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/e7/0f211736c1c3e20674db622c143c5681c1732e DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/e7/0f211736c1c3e20674db622c143c5681c1732e
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/e7/0f211736c1c3e20674db622c143c5681c1732e	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/e7/0f211736c1c3e20674db622c143c5681c1732e	2016-03-30 10:17:46.820403640 +0500
@@ -0,0 +1,2 @@
+xj0;){IKhPhI%cCGq|Ĕ{6A>
+|s%*ػvFBste;t愎1$6ĎoޠUm6,IZt=9-O\\9G}p/Y,>1YBOC1x*u؀!*HϵImOV:c*Oh0R5ԡUIkZoD
\ В конце файла нет новой строки
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/e8/106e641067e964771c19b93717286e7da80ea3 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/e8/106e641067e964771c19b93717286e7da80ea3 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/ed/786ce62fe12273b103f12d955d4b746aa63d08 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/ed/786ce62fe12273b103f12d955d4b746aa63d08 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/ee/fd5c5727ecbf701a328de3f3e2eb2e386586c3 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/ee/fd5c5727ecbf701a328de3f3e2eb2e386586c3 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/f0/2433e645a2d313d32fedad4fe94ec1c25ac708 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/f0/2433e645a2d313d32fedad4fe94ec1c25ac708 differ
Binary files DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/fa/0518668df7ad967ab177ac245d439f14235392 and DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/fa/0518668df7ad967ab177ac245d439f14235392 differ
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/ff/2397d43d39e6480191730c8854d041508cb6c9 DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/ff/2397d43d39e6480191730c8854d041508cb6c9
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/objects/ff/2397d43d39e6480191730c8854d041508cb6c9	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/objects/ff/2397d43d39e6480191730c8854d041508cb6c9	2015-12-30 15:04:18.000000000 +0500
@@ -0,0 +1 @@
+x-	 Fឝ⇮CpXc*Qn_^ZcʞMH)JD>WJ0,ckE&>ä 
\ В конце файла нет новой строки
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/packed-refs DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/packed-refs
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/packed-refs	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/packed-refs	2015-12-30 15:04:18.000000000 +0500
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled 
+5d2ece66c2a57d90be9c71426d981cd72778746f refs/remotes/origin/master
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/refs/heads/master DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/refs/heads/master
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/refs/heads/master	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/refs/heads/master	2016-02-23 18:35:55.000000000 +0500
@@ -0,0 +1 @@
+11023f27c9d130c8d46a0c8a15d491fe10c3a273
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/refs/remotes/origin/HEAD DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/refs/remotes/origin/HEAD
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/refs/remotes/origin/HEAD	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/refs/remotes/origin/HEAD	2015-12-30 15:04:18.000000000 +0500
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/refs/remotes/origin/master DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/refs/remotes/origin/master
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/.git/refs/remotes/origin/master	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/.git/refs/remotes/origin/master	2016-03-30 10:17:46.981403985 +0500
@@ -0,0 +1 @@
+75c230f5ada31a4a8000465de6ac2eea5c27f076
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/keywords.txt DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/keywords.txt
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/keywords.txt	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/keywords.txt	2015-02-17 19:04:31.000000000 +0500
@@ -0,0 +1,7 @@
+FastSerial	KEYWORD1
+begin		KEYWORD2
+end		KEYWORD2
+available	KEYWORD2
+read		KEYWORD2
+flush		KEYWORD2
+write		KEYWORD2
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/macros.inc DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/macros.inc
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/macros.inc	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/macros.inc	2015-02-17 19:04:31.000000000 +0500
@@ -0,0 +1,365 @@
+/* Copyright (c) 2002, 2005, 2006, 2007 Marek Michalkiewicz
+   Copyright (c) 2006 Dmitry Xmelkov
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/*
+   macros.inc - macros for use in assembler sources
+
+   Contributors:
+     Created by Marek Michalkiewicz <marekm@linux.org.pl>
+ */
+
+#include <avr/io.h>
+//#include "sectionname.h"
+
+/* if not defined, assume old version with underscores */
+#ifndef __USER_LABEL_PREFIX__
+#define __USER_LABEL_PREFIX__ _
+#endif
+
+#ifndef __REGISTER_PREFIX__
+#define __REGISTER_PREFIX__
+#endif
+
+/* the assembler line separator (just in case it ever changes) */
+#define _L $
+
+#define CONCAT1(a, b) CONCAT2(a, b)
+#define CONCAT2(a, b) a ## b
+
+#define _U(x) CONCAT1(__USER_LABEL_PREFIX__, x)
+
+#define _R(x) CONCAT1(__REGISTER_PREFIX__, x)
+
+/* these should help to fix the "can't have function named r1()" bug
+   which may require adding '%' in front of register names.  */
+
+#define r0 _R(r0)
+#define r1 _R(r1)
+#define r2 _R(r2)
+#define r3 _R(r3)
+#define r4 _R(r4)
+#define r5 _R(r5)
+#define r6 _R(r6)
+#define r7 _R(r7)
+#define r8 _R(r8)
+#define r9 _R(r9)
+#define r10 _R(r10)
+#define r11 _R(r11)
+#define r12 _R(r12)
+#define r13 _R(r13)
+#define r14 _R(r14)
+#define r15 _R(r15)
+#define r16 _R(r16)
+#define r17 _R(r17)
+#define r18 _R(r18)
+#define r19 _R(r19)
+#define r20 _R(r20)
+#define r21 _R(r21)
+#define r22 _R(r22)
+#define r23 _R(r23)
+#define r24 _R(r24)
+#define r25 _R(r25)
+#define r26 _R(r26)
+#define r27 _R(r27)
+#define r28 _R(r28)
+#define r29 _R(r29)
+#define r30 _R(r30)
+#define r31 _R(r31)
+
+#ifndef __tmp_reg__
+#define __tmp_reg__ r0
+#endif
+
+#ifndef __zero_reg__
+#define __zero_reg__ r1
+#endif
+
+#if __AVR_MEGA__
+  #define XJMP jmp
+  #define XCALL call
+#else
+  #define XJMP rjmp
+  #define XCALL rcall
+#endif
+
+/* used only by fplib/strtod.S - libgcc internal function calls */
+#define PROLOGUE_SAVES(offset) XJMP (__prologue_saves__ + 2 * (offset))
+#define EPILOGUE_RESTORES(offset) XJMP (__epilogue_restores__ + 2 * (offset))
+
+#if FLASHEND > 0x10000  /* ATmega103 */
+  #define BIG_CODE 1
+#else
+  #define BIG_CODE 0
+#endif
+
+#ifndef __AVR_HAVE_MOVW__
+#  if  defined(__AVR_ENHANCED__) && __AVR_ENHANCED__
+#   define __AVR_HAVE_MOVW__ 1
+#  endif
+#endif
+
+#ifndef __AVR_HAVE_LPMX__
+# if  defined(__AVR_ENHANCED__) && __AVR_ENHANCED__
+#  define __AVR_HAVE_LPMX__ 1
+# endif
+#endif
+
+#ifndef __AVR_HAVE_MUL__
+# if  defined(__AVR_ENHANCED__) && __AVR_ENHANCED__
+#  define __AVR_HAVE_MUL__ 1
+# endif
+#endif
+
+/*
+   Smart version of movw:
+    - uses "movw" if possible (supported by MCU, and both registers even)
+    - handles overlapping register pairs correctly
+    - no instruction generated if source and destination are the same
+   (may expand to 0, 1 or 2 instructions).
+ */
+
+.macro  X_movw dst src
+	.L_movw_dst = -1
+	.L_movw_src = -1
+	.L_movw_n = 0
+	.irp  reg,	r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, \
+			r10,r11,r12,r13,r14,r15,r16,r17,r18,r19, \
+			r20,r21,r22,r23,r24,r25,r26,r27,r28,r29, \
+			r30,r31
+		.ifc  \reg,\dst
+			.L_movw_dst = .L_movw_n
+		.endif
+		.ifc  \reg,\src
+			.L_movw_src = .L_movw_n
+		.endif
+		.L_movw_n = .L_movw_n + 1
+	.endr
+	.L_movw_n = 0
+	.irp  reg,	R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, \
+			R10,R11,R12,R13,R14,R15,R16,R17,R18,R19, \
+			R20,R21,R22,R23,R24,R25,R26,R27,R28,R29, \
+			R30,R31
+		.ifc  \reg,\dst
+			.L_movw_dst = .L_movw_n
+		.endif
+		.ifc  \reg,\src
+			.L_movw_src = .L_movw_n
+		.endif
+		.L_movw_n = .L_movw_n + 1
+	.endr
+	.if   .L_movw_dst < 0
+		.L_movw_n = 0
+		.rept   32
+			.if \dst == .L_movw_n
+				.L_movw_dst = .L_movw_n
+			.endif
+			.L_movw_n = .L_movw_n + 1
+		.endr
+	.endif
+	.if   .L_movw_src < 0
+		.L_movw_n = 0
+		.rept   32
+			.if \src == .L_movw_n
+				.L_movw_src = .L_movw_n
+			.endif
+			.L_movw_n = .L_movw_n + 1
+		.endr
+	.endif
+	.if   (.L_movw_dst < 0) || (.L_movw_src < 0)
+		.err    ; Invalid 'X_movw' arg.
+	.endif
+                
+	.if ((.L_movw_src) - (.L_movw_dst))  /* different registers */
+		.if (((.L_movw_src) | (.L_movw_dst)) & 0x01)
+			.if (((.L_movw_src)-(.L_movw_dst)) & 0x80) /* src < dest */
+				mov     (.L_movw_dst)+1, (.L_movw_src)+1
+				mov     (.L_movw_dst), (.L_movw_src)
+			.else                                      /* src > dest */
+				mov     (.L_movw_dst), (.L_movw_src)
+				mov     (.L_movw_dst)+1, (.L_movw_src)+1
+			.endif
+		.else  /* both even -> overlap not possible */
+#if  defined(__AVR_HAVE_MOVW__) && __AVR_HAVE_MOVW__
+			movw    \dst, \src
+#else
+			mov     (.L_movw_dst), (.L_movw_src)
+			mov     (.L_movw_dst)+1, (.L_movw_src)+1
+#endif
+		.endif
+	.endif
+.endm
+
+/* Macro 'X_lpm' extends enhanced lpm instruction for classic chips.
+   Usage:
+	X_lpm	reg, dst
+   where
+	reg	is 0..31, r0..r31 or R0..R31
+	dst	is z, Z, z+ or Z+
+   It is possible to omit both arguments.
+
+   Possible results for classic chips:
+	lpm
+	lpm / mov Rd,r0
+	lpm / adiw ZL,1
+	lpm / mov Rd,r0 / adiw ZL,1
+	
+   For enhanced chips it is one instruction always.
+
+   ATTENTION:  unlike enhanced chips SREG (S,V,N,Z,C) flags are
+   changed in case of 'Z+' dst.  R0 is scratch.
+ */
+.macro	X_lpm	dst=r0, src=Z
+
+  /* dst evaluation	*/
+  .L_lpm_dst = -1
+
+  .L_lpm_n = 0
+  .irp  reg,  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, \
+	     r10,r11,r12,r13,r14,r15,r16,r17,r18,r19, \
+	     r20,r21,r22,r23,r24,r25,r26,r27,r28,r29, \
+	     r30,r31
+    .ifc  \reg,\dst
+      .L_lpm_dst = .L_lpm_n
+    .endif
+    .L_lpm_n = .L_lpm_n + 1
+  .endr
+
+  .L_lpm_n = 0
+  .irp  reg,  R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, \
+	     R10,R11,R12,R13,R14,R15,R16,R17,R18,R19, \
+	     R20,R21,R22,R23,R24,R25,R26,R27,R28,R29, \
+	     R30,R31
+    .ifc  \reg,\dst
+      .L_lpm_dst = .L_lpm_n
+    .endif
+    .L_lpm_n = .L_lpm_n + 1
+  .endr
+
+  .if  .L_lpm_dst < 0
+    .L_lpm_n = 0
+    .rept 32
+      .if  \dst == .L_lpm_n
+	.L_lpm_dst = .L_lpm_n
+      .endif
+      .L_lpm_n = .L_lpm_n + 1
+    .endr
+  .endif
+
+  .if  (.L_lpm_dst < 0)
+    .err	; Invalid dst arg of 'X_lpm' macro.
+  .endif
+
+  /* src evaluation	*/    
+  .L_lpm_src = -1
+  .L_lpm_n = 0
+  .irp  reg,  z,Z,z+,Z+
+    .ifc  \reg,\src
+      .L_lpm_src = .L_lpm_n
+    .endif
+    .L_lpm_n = .L_lpm_n + 1
+  .endr
+
+  .if  (.L_lpm_src < 0)
+    .err	; Invalid src arg of 'X_lpm' macro.
+  .endif
+
+  /* instruction(s)	*/    
+  .if  .L_lpm_src < 2
+    .if  .L_lpm_dst == 0
+	lpm
+    .else
+#if  defined(__AVR_HAVE_LPMX__) && __AVR_HAVE_LPMX__
+	lpm	.L_lpm_dst, Z
+#else
+	lpm
+	mov	.L_lpm_dst, r0
+#endif
+    .endif
+  .else
+    .if  (.L_lpm_dst >= 30)
+      .err	; Registers 30 and 31 are inhibited as 'X_lpm *,Z+' dst.
+    .endif
+#if  defined(__AVR_HAVE_LPMX__) && __AVR_HAVE_LPMX__
+	lpm	.L_lpm_dst, Z+
+#else
+	lpm
+    .if  .L_lpm_dst
+	mov	.L_lpm_dst, r0
+    .endif
+	adiw	r30, 1
+#endif
+  .endif
+.endm
+
+/*
+   LPM_R0_ZPLUS_INIT is used before the loop to initialize RAMPZ
+   for future devices with RAMPZ:Z auto-increment - [e]lpm r0, Z+.
+
+   LPM_R0_ZPLUS_NEXT is used inside the loop to load a byte from
+   the program memory at [RAMPZ:]Z to R0, and increment [RAMPZ:]Z.
+
+   The argument in both macros is a register that contains the
+   high byte (bits 23-16) of the address, bits 15-0 should be in
+   the Z (r31:r30) register.  It can be any register except for:
+   r0, r1 (__zero_reg__ - assumed to always contain 0), r30, r31.
+ */
+
+	.macro	LPM_R0_ZPLUS_INIT hhi
+#if __AVR_ENHANCED__
+  #if BIG_CODE
+	out	AVR_RAMPZ_ADDR, \hhi
+  #endif
+#endif
+	.endm
+
+	.macro	LPM_R0_ZPLUS_NEXT hhi
+#if __AVR_ENHANCED__
+  #if BIG_CODE
+    /* ELPM with RAMPZ:Z post-increment, load RAMPZ only once */
+	elpm	r0, Z+
+  #else
+    /* LPM with Z post-increment, max 64K, no RAMPZ (ATmega83/161/163/32) */
+	lpm	r0, Z+
+  #endif
+#else
+  #if BIG_CODE
+    /* ELPM without post-increment, load RAMPZ each time (ATmega103) */
+	out	AVR_RAMPZ_ADDR, \hhi
+	elpm
+	adiw	r30,1
+	adc	\hhi, __zero_reg__
+  #else
+    /* LPM without post-increment, max 64K, no RAMPZ (AT90S*) */
+	lpm
+	adiw	r30,1
+  #endif
+#endif
+	.endm
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/MyStream.cpp DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/MyStream.cpp
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/MyStream.cpp	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/MyStream.cpp	2016-01-25 16:18:08.000000000 +0500
@@ -0,0 +1,323 @@
+/*
+ Stream.cpp - adds parsing methods to Stream class
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Created July 2011
+ parsing functions based on TextFinder library by Michael Margolis
+
+ findMulti/findUntil routines written by Jim Leonard/Xuth
+ */
+
+#include "MyStream.h"
+
+#include "Arduino.h"
+
+#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
+#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field
+
+
+unsigned int MyStream::_timeout=1000;      // number of milliseconds to wait for the next char before aborting timed read
+unsigned long MyStream::_startMillis;
+
+// private method to read stream with timeout
+uint8_t MyStream::timedRead()
+{
+  int c;
+  _startMillis = millis();
+  do {
+    c = read();
+    if (c >= 0) return c;
+  } while(millis() - _startMillis < _timeout);
+  return -1;     // -1 indicates timeout
+}
+
+// private method to peek stream with timeout
+uint8_t MyStream::timedPeek()
+{
+  int c;
+  _startMillis = millis();
+  do {
+    c = peek();
+    if (c >= 0) return c;
+  } while(millis() - _startMillis < _timeout);
+  return -1;     // -1 indicates timeout
+}
+
+// returns peek of the next digit in the stream or -1 if timeout
+// discards non-numeric characters
+uint8_t MyStream::peekNextDigit()
+{
+  int c;
+  while (1) {
+    c = timedPeek();
+    if (c < 0) return c;  // timeout
+    if (c == '-') return c;
+    if (c >= '0' && c <= '9') return c;
+    read();  // discard non-numeric
+  }
+}
+
+// Public Methods
+//////////////////////////////////////////////////////////////
+
+void MyStream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
+{
+  _timeout = timeout;
+}
+
+ // find returns true if the target string is found
+bool  MyStream::find(char *target)
+{
+  return findUntil(target, strlen(target), NULL, 0);
+}
+
+// reads data from the stream until the target string of given length is found
+// returns true if target string is found, false if timed out
+bool MyStream::find(char *target, size_t length)
+{
+  return findUntil(target, length, NULL, 0);
+}
+
+// as find but search ends if the terminator string is found
+bool  MyStream::findUntil(char *target, char *terminator)
+{
+  return findUntil(target, strlen(target), terminator, strlen(terminator));
+}
+
+// reads data from the stream until the target string of the given length is found
+// search terminated if the terminator string is found
+// returns true if target string is found, false if terminated or timed out
+bool MyStream::findUntil(char *target, size_t targetLen, char *terminator, size_t termLen)
+{
+  if (terminator == NULL) {
+    MultiTarget t[1] = {{target, targetLen, 0}};
+    return findMulti(t, 1) == 0 ? true : false;
+  } else {
+    MultiTarget t[2] = {{target, targetLen, 0}, {terminator, termLen, 0}};
+    return findMulti(t, 2) == 0 ? true : false;
+  }
+}
+
+
+// returns the first valid (long) integer value from the current position.
+// initial characters that are not digits (or the minus sign) are skipped
+// function is terminated by the first character that is not a digit.
+long MyStream::parseInt()
+{
+  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
+}
+
+// as above but a given skipChar is ignored
+// this allows format characters (typically commas) in values to be ignored
+long MyStream::parseInt(char skipChar)
+{
+  bool isNegative = false;
+  long value = 0;
+  int c;
+
+  c = peekNextDigit();
+  // ignore non numeric leading characters
+  if(c < 0)
+    return 0; // zero returned if timeout
+
+  do{
+    if(c == skipChar)
+      ; // ignore this charactor
+    else if(c == '-')
+      isNegative = true;
+    else if(c >= '0' && c <= '9')        // is c a digit?
+      value = value * 10 + c - '0';
+    read();  // consume the character we got with peek
+    c = timedPeek();
+  }
+  while( (c >= '0' && c <= '9') || c == skipChar );
+
+  if(isNegative)
+    value = -value;
+  return value;
+}
+
+
+// as parseInt but returns a floating point value
+float MyStream::parseFloat()
+{
+  return parseFloat(NO_SKIP_CHAR);
+}
+
+// as above but the given skipChar is ignored
+// this allows format characters (typically commas) in values to be ignored
+float MyStream::parseFloat(char skipChar){
+  bool isNegative = false;
+  bool isFraction = false;
+  long value = 0;
+  char c;
+  float fraction = 1.0;
+
+  c = peekNextDigit();
+    // ignore non numeric leading characters
+  if(c < 0)
+    return 0; // zero returned if timeout
+
+  do{
+    if(c == skipChar)
+      ; // ignore
+    else if(c == '-')
+      isNegative = true;
+    else if (c == '.')
+      isFraction = true;
+    else if(c >= '0' && c <= '9')  {      // is c a digit?
+      value = value * 10 + c - '0';
+      if(isFraction)
+         fraction *= 0.1;
+    }
+    read();  // consume the character we got with peek
+    c = timedPeek();
+  }
+  while( (c >= '0' && c <= '9')  || c == '.' || c == skipChar );
+
+  if(isNegative)
+    value = -value;
+  if(isFraction)
+    return value * fraction;
+  else
+    return value;
+}
+
+// read characters from stream into buffer
+// terminates if length characters have been read, or timeout (see setTimeout)
+// returns the number of characters placed in the buffer
+// the buffer is NOT null terminated.
+//
+size_t MyStream::readBytes(char *buffer, size_t length)
+{
+  size_t count = 0;
+  while (count < length) {
+    int c = timedRead();
+    if (c < 0) break;
+    *buffer++ = (char)c;
+    count++;
+  }
+  return count;
+}
+
+
+// as readBytes with terminator character
+// terminates if length characters have been read, timeout, or if the terminator character  detected
+// returns the number of characters placed in the buffer (0 means no valid data found)
+
+size_t MyStream::readBytesUntil(char terminator, char *buffer, size_t length)
+{
+  if (length < 1) return 0;
+  size_t index = 0;
+  while (index < length) {
+    int c = timedRead();
+    if (c < 0 || c == terminator) break;
+    *buffer++ = (char)c;
+    index++;
+  }
+  return index; // return number of characters, not including null terminator
+}
+
+String MyStream::readString()
+{
+  String ret;
+  int c = timedRead();
+  while (c >= 0)
+  {
+    ret += (char)c;
+    c = timedRead();
+  }
+  return ret;
+}
+
+String MyStream::readStringUntil(char terminator)
+{
+  String ret;
+  int c = timedRead();
+  while (c >= 0 && c != terminator)
+  {
+    ret += (char)c;
+    c = timedRead();
+  }
+  return ret;
+}
+
+int MyStream::findMulti( struct MyStream::MultiTarget *targets, int tCount) {
+  // any zero length target string automatically matches and would make
+  // a mess of the rest of the algorithm.
+  for (struct MultiTarget *t = targets; t < targets+tCount; ++t) {
+    if (t->len <= 0)
+      return t - targets;
+  }
+
+  while (1) {
+    int c = timedRead();
+    if (c < 0)
+      return -1;
+
+    for (struct MultiTarget *t = targets; t < targets+tCount; ++t) {
+      // the simple case is if we match, deal with that first.
+      if (c == t->str[t->index]) {
+        if (++t->index == t->len)
+          return t - targets;
+        else
+          continue;
+      }
+
+      // if not we need to walk back and see if we could have matched further
+      // down the stream (ie '1112' doesn't match the first position in '11112'
+      // but it will match the second position so we can't just reset the current
+      // index to 0 when we find a mismatch.
+      if (t->index == 0)
+        continue;
+
+      int origIndex = t->index;
+      do {
+        --t->index;
+        // first check if current char works against the new current index
+        if (c != t->str[t->index])
+          continue;
+
+        // if it's the only char then we're good, nothing more to check
+        if (t->index == 0) {
+          t->index++;
+          break;
+        }
+
+        // otherwise we need to check the rest of the found string
+        int diff = origIndex - t->index;
+        size_t i;
+        for (i = 0; i < t->index; ++i) {
+          if (t->str[i] != t->str[i + diff])
+            break;
+        }
+
+        // if we successfully got through the previous loop then our current
+        // index is good.
+        if (i == t->index) {
+          t->index++;
+          break;
+        }
+
+        // otherwise we just try the next index
+      } while (t->index);
+    }
+  }
+  // unreachable
+  return -1;
+}
+
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/MyStream.h DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/MyStream.h
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/MyStream.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/MyStream.h	2016-03-23 17:22:51.000000000 +0500
@@ -0,0 +1,117 @@
+/*
+  Stream.h - base class for character-based streams.
+  Copyright (c) 2010 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  parsing functions based on TextFinder library by Michael Margolis
+*/
+
+#ifndef myStream_h
+#define myStream_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+// compatability macros for testing
+/*
+#define   getInt()            parseInt()
+#define   getInt(skipChar)    parseInt(skipchar)
+#define   getFloat()          parseFloat()
+#define   getFloat(skipChar)  parseFloat(skipChar)
+#define   getString( pre_string, post_string, buffer, length)
+readBytesBetween( pre_string, terminator, buffer, length)
+*/
+
+class MyStream : public Print
+{
+  protected:
+    static unsigned int _timeout;      // number of milliseconds to wait for the next char before aborting timed read
+    static unsigned long _startMillis;  // used for timeout measurement
+    uint8_t timedRead();    // private method to read stream with timeout
+    uint8_t timedPeek();    // private method to peek stream with timeout
+    uint8_t peekNextDigit(); // returns the next numeric digit in the stream or -1 if timeout
+
+  public:
+    virtual uint8_t available() = 0;
+    virtual uint8_t read() = 0;
+    virtual uint8_t peek() = 0;
+    virtual void flush() = 0;
+
+    MyStream() { /*_timeout=1000; */ }
+
+    size_t _write(uint8_t c){ return write(c); }
+    
+// parsing methods
+
+  void setTimeout(unsigned long timeout);  // sets maximum milliseconds to wait for stream data, default is 1 second
+
+  bool find(char *target);   // reads data from the stream until the target string is found
+  bool find(uint8_t *target) { return find ((char *)target); }
+  // returns true if target string is found, false if timed out (see setTimeout)
+
+  bool find(char *target, size_t length);   // reads data from the stream until the target string of given length is found
+  bool find(uint8_t *target, size_t length) { return find ((char *)target, length); }
+  // returns true if target string is found, false if timed out
+
+  bool find(char target) { return find (&target, 1); }
+
+  bool findUntil(char *target, char *terminator);   // as find but search ends if the terminator string is found
+  bool findUntil(uint8_t *target, char *terminator) { return findUntil((char *)target, terminator); }
+
+  bool findUntil(char *target, size_t targetLen, char *terminate, size_t termLen);   // as above but search ends if the terminate string is found
+  bool findUntil(uint8_t *target, size_t targetLen, char *terminate, size_t termLen) {return findUntil((char *)target, targetLen, terminate, termLen); }
+
+
+  long parseInt(); // returns the first valid (long) integer value from the current position.
+  // initial characters that are not digits (or the minus sign) are skipped
+  // integer is terminated by the first character that is not a digit.
+
+  float parseFloat();               // float version of parseInt
+
+  size_t readBytes( char *buffer, size_t length); // read chars from stream into buffer
+  size_t readBytes( uint8_t *buffer, size_t length) { return readBytes((char *)buffer, length); }
+  // terminates if length characters have been read or timeout (see setTimeout)
+  // returns the number of characters placed in the buffer (0 means no valid data found)
+
+  size_t readBytesUntil( char terminator, char *buffer, size_t length); // as readBytes with terminator character
+  size_t readBytesUntil( char terminator, uint8_t *buffer, size_t length) { return readBytesUntil(terminator, (char *)buffer, length); }
+  // terminates if length characters have been read, timeout, or if the terminator character  detected
+  // returns the number of characters placed in the buffer (0 means no valid data found)
+
+  // Arduino String functions to be added here
+  String readString();
+  String readStringUntil(char terminator);
+
+  protected:
+  long parseInt(char skipChar); // as above but the given skipChar is ignored
+  // as above but the given skipChar is ignored
+  // this allows format characters (typically commas) in values to be ignored
+
+  float parseFloat(char skipChar);  // as above but the given skipChar is ignored
+
+  struct MultiTarget {
+    const char *str;  // string you're searching for
+    size_t len;       // length of string you're searching for
+    size_t index;     // index used by the search routine.
+  };
+
+  // This allows you to search for an arbitrary number of strings.
+  // Returns index of the target that is found first or -1 if timeout occurs.
+  int findMulti(struct MultiTarget *targets, int tCount);
+};
+
+
+#endif
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/ntz.h DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/ntz.h
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/ntz.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/ntz.h	2015-02-17 19:04:31.000000000 +0500
@@ -0,0 +1,54 @@
+/* Copyright (c) 2007, Dmitry Xmelkov
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: ntz.h 1217 2007-02-18 13:18:05Z dmix $	*/
+
+#ifndef	_NTZ_H
+#define	_NTZ_H
+
+/* Number of Tail Zeros:  ntz(x)= (ffs(x) ? ffs(x)-1 : 16)
+   It works with all: cpp, gcc and gas expressions.	*/
+#define ntz(x)	\
+	( (1 & (((x) & 1) == 0))        \
+	+ (1 & (((x) & 3) == 0))        \
+    	+ (1 & (((x) & 7) == 0))        \
+        + (1 & (((x) & 017) == 0))      \
+        + (1 & (((x) & 037) == 0))      \
+	+ (1 & (((x) & 077) == 0))      \
+	+ (1 & (((x) & 0177) == 0))     \
+	+ (1 & (((x) & 0377) == 0))     \
+	+ (1 & (((x) & 0777) == 0))     \
+	+ (1 & (((x) & 01777) == 0))    \
+	+ (1 & (((x) & 03777) == 0))    \
+	+ (1 & (((x) & 07777) == 0))    \
+	+ (1 & (((x) & 017777) == 0))   \
+	+ (1 & (((x) & 037777) == 0))   \
+	+ (1 & (((x) & 077777) == 0))   \
+	+ (1 & (((x) & 0177777) == 0)) )
+
+#endif	/* !_NTZ_H */
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/README.md DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/README.md
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/README.md	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/README.md	2015-12-30 16:51:10.000000000 +0500
@@ -0,0 +1,31 @@
+# SingleSerial
+Simple and fast serial library for chips with single hardware serial
+
+speed as FastSerial with tiny size
+
+sizes of sketch DigitalReadSerial from Arduino samples
+
+
+uses		HardwareSerial		FastSerial	SingleSerial
+flash		2636			3848		2300 
+ram static	202			109		203
+ram full				253
+
+
+ram full means: 
+with SingleSerial & HardwareSerial  RX & TX buffers allocated statically,
+where FastSerial uses dynamic memory allocation via malloc()
+
+FastSerial uses 16 bytes TX and 128 RX so full memory usage is 253 bytes
+HardwareSerial by default uses 64 bytes TX and 64 RX static buffers
+SingleSerial by default uses 16 bytes TX and 128 RX static buffers
+
+see the above table again :)
+
+restrictions: 
+
+* only one port
+* buffers 256 bytes max
+* no non-blocking write
+* buffer sizes must be power of 2
+
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/SingleSerial.cpp DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/SingleSerial.cpp
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/SingleSerial.cpp	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/SingleSerial.cpp	2017-04-13 17:42:11.532630847 +0500
@@ -0,0 +1,249 @@
+// -*-  tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: t -*-
+//
+// Simple and fast Interrupt-driven serial transmit/receive library for chips with single hardware serial port
+//
+//	Copyright (c) 2015 NightGhost night_ghost@ykoctpa.ru  All rights reserved..
+//
+// based on FastSerial by Michael Smith and Arduino's HardwareSerial
+//
+//      Copyright (c) 2010 Michael Smith. All rights reserved.
+//
+// Receive and baudrate calculations derived from the Arduino
+// HardwareSerial driver:
+//
+//      Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+//
+// Transmit algorithm inspired by work:
+//
+//      Code Jose Julio and Jordi Munoz. DIYDrones.com
+//
+//      This library is free software; you can redistribute it and/or
+//      modify it under the terms of the GNU Lesser General Public
+//      License as published by the Free Software Foundation; either
+//      version 2.1 of the License, or (at your option) any later version.
+//
+//      This library is distributed in the hope that it will be useful,
+//      but WITHOUT ANY WARRANTY; without even the implied warranty of
+//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//      Lesser General Public License for more details.
+//
+//      You should have received a copy of the GNU Lesser General Public
+//      License along with this library; if not, write to the Free Software
+//      Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+
+
+#include "SingleSerial.h"
+
+#if defined(ARDUINO) && ARDUINO >= 100
+	#include "Arduino.h"
+#else
+	#include "WProgram.h"
+#endif
+
+
+SingleSerial::Buffer SingleSerial::_rxBuffer;
+SingleSerial::Buffer SingleSerial::_txBuffer;
+
+uint8_t SingleSerial::_rxBytes[SERIAL_RX_BUFFER_SIZE];
+uint8_t SingleSerial::_txBytes[SERIAL_TX_BUFFER_SIZE];
+
+#ifdef DEBUG
+extern volatile uint16_t lost_bytes;
+#endif
+
+#define IS_OPEN (UCSR0B & _BV(RXEN0) )
+
+// Constructor /////////////////////////////////////////////////////////////////
+
+SingleSerial::SingleSerial() 
+{
+//	begin(57600); no autostart!
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void SingleSerial::begin(unsigned long baud)
+{
+	uint16_t ubrr;
+	bool use_u2x = true;
+
+	// if we are currently open...
+	if (IS_OPEN) {
+		end();
+	}
+
+	// reset buffer pointers
+	_txBuffer.head = _txBuffer.tail = 0;
+	_rxBuffer.head = _rxBuffer.tail = 0;
+
+	// If the user has supplied a new baud rate, compute the new UBRR value.
+	if (baud > 0) {
+//*
+#if F_CPU == 16000000UL
+		// hardcoded exception for compatibility with the bootloader shipped
+		// with the Duemilanove and previous boards and the firmware on the 8U2
+		// on the Uno and Mega 2560.
+		if (baud == 57600)
+			use_u2x = false;
+#endif
+//*/
+		if (use_u2x) {
+			UCSR0A = 1 << U2X0;
+			ubrr = (F_CPU / 4 / baud - 1) / 2;
+		} else {
+			UCSR0A = 0;
+			ubrr = (F_CPU / 8 / baud - 1) / 2;
+		}
+
+		UBRR0H = ubrr >> 8;
+		UBRR0L = ubrr;
+	}
+
+	//UCSR0B |= (_BV(RXEN0) |  _BV(TXEN0) | _BV(RXCIE0));
+	UCSR0B = _BV(RXEN0) |  _BV(TXEN0) | _BV(RXCIE0);
+	UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); // 8 bit
+}
+
+void SingleSerial::begin(unsigned long baud, uint8_t mode)
+{
+    begin(baud);
+    UCSR0C = mode;
+}
+
+
+void SingleSerial::end(){
+	//UCSR0B &= ~((_BV(RXEN0) |  _BV(TXEN0) | _BV(RXCIE0)) | _BV(UDRIE0));
+	UCSR0B = 0;
+
+}
+
+uint8_t SingleSerial::available_S(void){
+	if (!IS_OPEN)
+		return 0;
+	return ((_rxBuffer.head - _rxBuffer.tail) & (SERIAL_RX_BUFFER_SIZE -1) );
+}
+
+uint8_t SingleSerial::available(void)
+{
+	return available_S();
+}
+
+/*
+uint8_t SingleSerial::txspace(void)
+{
+	if (!IS_OPEN)
+		return (0);
+	return ((SERIAL_TX_BUFFER_SIZE) - ((_txBuffer.head - _txBuffer.tail) & SERIAL_TX_BUFFER_SIZE));
+}
+*/
+uint8_t SingleSerial::read_S(void)
+{
+	uint8_t c;
+
+	// if the head and tail are equal, the buffer is empty
+	if (!IS_OPEN || (_rxBuffer.head == _rxBuffer.tail))
+		return 0;
+
+	// pull character from tail
+	c = _rxBytes[_rxBuffer.tail];
+	_rxBuffer.tail = (_rxBuffer.tail + 1) & (SERIAL_RX_BUFFER_SIZE-1);
+
+	return c;
+}
+
+uint8_t SingleSerial::read(void){
+    return read_S();
+}
+
+uint8_t SingleSerial::peek(void){
+
+	// if the head and tail are equal, the buffer is empty
+	if (!IS_OPEN || (_rxBuffer.head == _rxBuffer.tail))
+		return 0;
+
+	// pull character from tail
+	return _rxBytes[_rxBuffer.tail];
+}
+
+void SingleSerial::flush(void){
+	// don't reverse this or there may be problems if the RX interrupt
+	// occurs after reading the value of _rxBuffer->head but before writing
+	// the value to _rxBuffer->tail; the previous value of head
+	// may be written to tail, making it appear as if the buffer
+	// don't reverse this or there may be problems if the RX interrupt
+	// occurs after reading the value of head but before writing
+	// the value to tail; the previous value of rx_buffer_head
+	// may be written to tail, making it appear as if the buffer
+	// were full, not empty.
+	_rxBuffer.head = _rxBuffer.tail;
+
+	// don't reverse this or there may be problems if the TX interrupt
+	// occurs after reading the value of _txBuffer->tail but before writing
+	// the value to _txBuffer->head.
+	_txBuffer.tail = _txBuffer.head;
+
+#ifdef DEBUG
+    lost_bytes=0;
+#endif
+
+}
+
+void SingleSerial::wait(void){
+    while (SingleSerial::_txBuffer.tail != SingleSerial::_txBuffer.head);
+}
+
+#if defined(ARDUINO) && ARDUINO >= 100
+
+void SingleSerial::write_S(uint8_t c)
+{
+	uint8_t i;
+
+	if (!IS_OPEN) // drop bytes if not open
+		return;
+
+	
+	i = (_txBuffer.head + 1) & (SERIAL_TX_BUFFER_SIZE-1);
+
+	while (i == _txBuffer.tail)// wait for room in the tx buffer
+		;
+
+	// add byte to the buffer
+	_txBytes[_txBuffer.head] = c;
+	_txBuffer.head = i;
+
+	// enable the data-ready interrupt, as it may be off if the buffer is empty
+	UCSR0B |= _BV(UDRIE0);
+}
+
+size_t SingleSerial::write(uint8_t c) {
+    write_S(c);
+    // return number of bytes written (always 1)
+    return 1;
+
+}
+
+
+#else
+void SingleSerial::write(uint8_t c)
+{
+	uint8_t i;
+
+	if (!IS_OPEN) // drop bytes if not open
+		return;
+
+	i = (_txBuffer.head + 1) & (SERIAL_TX_BUFFER_SIZE-1);
+	while (i == _txBuffer.tail) 	// wait for room in the tx buffer
+		;
+
+	// add byte to the buffer
+	_txBytes[_txBuffer.head] = c;
+	_txBuffer.head = i;
+
+	// enable the data-ready interrupt, as it may be off if the buffer is empty
+	UCSR0B |= _BV(UDRIE0));
+}
+#endif
+
+
+void serialEventRun(void){}
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/SingleSerial.h DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/SingleSerial.h
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/SingleSerial.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/SingleSerial.h	2017-04-13 17:32:50.803680487 +0500
@@ -0,0 +1,258 @@
+// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: t -*-
+//
+//
+//
+// Simple and fast Interrupt-driven serial transmit/receive library for chips with single hardware serial port
+//
+//	Copyright (c) 2015 NightGhost night_ghost@ykoctpa.ru  All rights reserved. 
+//
+// based on FastSerial by Michael Smith and Arduino's HardwareSerial
+//
+//      Copyright (c) 2010 Michael Smith. All rights reserved.
+//
+// Receive and baudrate calculations derived from the Arduino
+// HardwareSerial driver:
+//
+//      Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+//
+// Transmit algorithm inspired by work:
+//
+//      Code Jose Julio and Jordi Munoz. DIYDrones.com
+//
+//      This library is free software; you can redistribute it and/or
+//      modify it under the terms of the GNU Lesser General Public
+//      License as published by the Free Software Foundation; either
+//      version 2.1 of the License, or (at your option) any later
+//      version.
+//
+//      This library is distributed in the hope that it will be
+//      useful, but WITHOUT ANY WARRANTY; without even the implied
+//      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//      PURPOSE.  See the GNU Lesser General Public License for more
+//      details.
+//
+//      You should have received a copy of the GNU Lesser General
+//      Public License along with this library; if not, write to the
+//      Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//      Boston, MA 02110-1301 USA
+//
+
+//
+// Note that this library does not pre-declare drivers for serial
+// ports; the user must explicitly create drivers for the ports they
+// wish to use.  This is less friendly than the stock Arduino driver,
+// but it saves a few bytes of RAM for every unused port and frees up
+// the vector for another driver (e.g. MSPIM on USARTs).
+//
+
+#ifndef SingleSerial_h
+#define SingleSerial_h
+
+// disable the stock Arduino serial driver
+#ifdef HardwareSerial_h
+# error Must include SingleSerial.h before the Arduino serial driver is defined.
+#endif
+#define HardwareSerial_h
+
+
+//#define DEBUG 1
+
+#include <inttypes.h>
+#include <stdlib.h>
+//#include <avr/io.h>
+//#include <avr/interrupt.h>
+
+#include "BetterStream.h"
+
+#if !defined(SERIAL_TX_BUFFER_SIZE)
+#define SERIAL_TX_BUFFER_SIZE 4
+#endif
+#if !defined(SERIAL_RX_BUFFER_SIZE)
+#define SERIAL_RX_BUFFER_SIZE 128 // 64 loses packets in 115200
+#endif
+
+/// @file	SingleSerial.h
+/// @brief	An enhanced version of the Arduino HardwareSerial class
+///			implementing interrupt-driven transmission 
+///
+/// Because Arduino libraries aren't really libraries, but we want to
+/// only define interrupt handlers for serial ports that are actually
+/// used, we have to force our users to define them using a macro.
+///
+/// SingleSerialPort(<port name>)
+///
+/// <port name> is the name of the object that will be created by the
+/// macro.
+
+///	@name	Compatibility
+///
+
+
+// Define config for Serial.begin(baud, config);
+#define SERIAL_5N1 0x00
+#define SERIAL_6N1 0x02
+#define SERIAL_7N1 0x04
+#define SERIAL_8N1 0x06
+#define SERIAL_5N2 0x08
+#define SERIAL_6N2 0x0A
+#define SERIAL_7N2 0x0C
+#define SERIAL_8N2 0x0E
+#define SERIAL_5E1 0x20
+#define SERIAL_6E1 0x22
+#define SERIAL_7E1 0x24
+#define SERIAL_8E1 0x26
+#define SERIAL_5E2 0x28
+#define SERIAL_6E2 0x2A
+#define SERIAL_7E2 0x2C
+#define SERIAL_8E2 0x2E
+#define SERIAL_5O1 0x30
+#define SERIAL_6O1 0x32
+#define SERIAL_7O1 0x34
+#define SERIAL_8O1 0x36
+#define SERIAL_5O2 0x38
+#define SERIAL_6O2 0x3A
+#define SERIAL_7O2 0x3C
+#define SERIAL_8O2 0x3E
+
+
+class SingleSerial: public BetterStream {
+public:
+
+	/// Constructor
+	SingleSerial();
+
+	/// @name 	Serial API
+    //@{
+	static void begin(unsigned long baud);
+	static void begin(unsigned long baud, uint8_t mode);
+	
+	static void end(void);
+	static  uint8_t read_S(void);
+	static uint8_t available_S(void);
+	static void write_S(uint8_t c);
+	virtual uint8_t available(void);
+//	virtual uint8_t txspace(void);
+	virtual uint8_t read(void);
+	virtual uint8_t peek(void);
+	virtual void flush(void);
+	static void wait();
+#if defined(ARDUINO) && ARDUINO >= 100
+	virtual size_t write(uint8_t c);
+#else
+	virtual void write(uint8_t c);
+#endif
+	using BetterStream::write;
+    //@}
+
+
+	/// Transmit/receive buffer descriptor.
+	///
+	/// Public so the interrupt handlers can see it
+	struct Buffer {
+		volatile uint8_t head, tail;	///< head and tail pointers
+	};
+
+	// ring buffers
+	static Buffer	_rxBuffer;
+	static Buffer	_txBuffer;
+	static uint8_t	_rxBytes[SERIAL_RX_BUFFER_SIZE];
+	static uint8_t	_txBytes[SERIAL_TX_BUFFER_SIZE];
+
+private:
+
+};
+
+
+
+/// Generic Rx/Tx vectors for a serial port 
+///
+#define SingleSerialHandler( _RXVECTOR, _TXVECTOR, _UDR, _UCSRB, _TXBITS) \
+ISR(_RXVECTOR, ISR_BLOCK)                                               \
+{                                                                       \
+        uint8_t c;                                                      \
+        uint8_t i;                                                      \
+                                                                        \
+        /* read the byte as quickly as possible */                      \
+        c = _UDR;                                                       \
+        /* work out where the head will go next */                      \
+        i = (SingleSerial::_rxBuffer.head + 1) & (SERIAL_RX_BUFFER_SIZE -1); \
+        /* decide whether we have space for another byte */             \
+        if (i != SingleSerial::_rxBuffer.tail) {                  \
+            /* we do, move the head */                              \
+            SingleSerial::_rxBytes[SingleSerial::_rxBuffer.head] = c; \
+            SingleSerial::_rxBuffer.head = i;                     \
+        } /* buffer overflow */                                   \
+/*        else    digitalWrite(LEDPIN, !digitalRead(LEDPIN));  */ \
+/*         else { extern volatile uint16_t lost_bytes; lost_bytes++; }*/ \
+}                                                                       \
+ISR(_TXVECTOR, ISR_BLOCK)                                               \
+{                                                                       \
+        /* if there is another character to send */                     \
+        if (SingleSerial::_txBuffer.tail != SingleSerial::_txBuffer.head) { \
+                _UDR = SingleSerial::_txBytes[SingleSerial::_txBuffer.tail]; \
+                /* increment the tail */                                \
+                SingleSerial::_txBuffer.tail =                    \
+                        (SingleSerial::_txBuffer.tail + 1) & (SERIAL_TX_BUFFER_SIZE-1); \
+        } else {                                                        \
+                /* there are no more bytes to send, disable the interrupt */ \
+            /*    if (SingleSerial::_txBuffer.head == SingleSerial::_txBuffer.tail) */ \
+                        _UCSRB &= ~_TXBITS;                             \
+        }                                                               \
+}                                                                       \
+struct hack
+
+
+///
+/// Macro defining a SingleSerial port instance.
+///
+#define SingleSerialPort(_name)   \
+      SingleSerialHandler(USART0_RX_vect, USART0_UDRE_vect, UDR0, UCSR0B, _BV(UDRIE0)); \
+      SingleSerial _name
+
+
+//
+// Portability; convert various older sets of defines for U(S)ART0 up
+// to match the definitions for the 1280 and later devices.
+//
+#if !defined(USART0_RX_vect)
+# if defined(USART_RX_vect)
+#  define USART0_RX_vect        USART_RX_vect
+#  define USART0_UDRE_vect      USART_UDRE_vect
+# elif defined(UART0_RX_vect)
+#  define USART0_RX_vect        UART0_RX_vect
+#  define USART0_UDRE_vect      UART0_UDRE_vect
+# endif
+#endif
+
+
+#if !defined(UDR0)
+# if defined(UDR)
+#  define UDR0                  UDR
+#  define UBRR0H                UBRRH
+#  define UBRR0L                UBRRL
+#  define UCSR0A                UCSRA
+#  define UCSR0B                UCSRB
+#  define U2X0                  U2X
+#  define RXEN0                 RXEN
+#  define TXEN0                 TXEN
+#  define RXCIE0                RXCIE
+#  define UDRIE0                UDRIE
+# endif
+#endif
+
+
+/// Forward declarations for clients that want to assume that the
+/// default Serial* objects exist.
+///
+/// Note that the application is responsible for ensuring that these
+/// actually get defined, otherwise Arduino will suck in the
+/// HardwareSerial library and linking will fail.
+//@{
+extern class SingleSerial Serial;
+//@}
+
+/// The SingleSerial class definition
+///
+
+
+#endif // SingleSerial_h
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/ultoa_invert.S DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/ultoa_invert.S
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/ultoa_invert.S	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/ultoa_invert.S	2015-02-17 19:04:31.000000000 +0500
@@ -0,0 +1,216 @@
+/* Copyright (c) 2005,2007  Dmitry Xmelkov
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: ultoa_invert.S 1944 2009-04-01 23:12:20Z arcanum $	*/
+
+#ifndef	__DOXYGEN__
+
+#include "macros.inc"
+#include "ntz.h"
+#include "xtoa_fast.h"
+
+/* --------------------------------------------------------------------
+   char * __ultoa_invert (unsigned long val, char * str, int base)
+
+   This function is intended for usage as internal printf's one.
+   It differs from others of `xtoa_fast' family:
+       * srt[] will NOT 0 terminated.
+       * Sequence of digits is inverted.
+       * It returns pointer to first byte after a string.
+       * Only `XTOA_UPPER' flag is operated.
+   Notes:
+       * base: check only 8 and 16, all others are treated as 10.
+       (internal printf's function).
+*/
+
+    /* Input	*/
+#define v_lo	r22
+#define	v_hi	r23
+#define	v_hlo	r24
+#define	v_hhi	r25
+#define	str_lo	r20
+#define	str_hi	r21
+#define	base	r18
+#define	flags	r19
+
+    /* Used	*/
+#define	v_fifth	r26	/* val: bits 39..32			*/
+#define	t_lo	r18	/* temporary for shifted `val'		*/
+#define	t_hi	r19
+#define	t_hlo	r20
+#define	t_hhi	r21
+#define	symb	r20	/* write to string			*/
+#define	cnt	r27	/* shift loop counter, local arg	*/
+
+    /* Fixed	*/
+#define	rzero	r1
+
+/*	ASSEMBLY_CLIB_SECTION */
+	.global	__ultoa_invert
+	.type	__ultoa_invert, "function"
+
+__ultoa_invert:
+	X_movw	ZL, str_lo
+	clr	v_fifth			; needed for all (ultoa_lsr)
+	cpi	base, 8
+	breq	.L_oct
+	cpi	base, 16
+	breq	.L_hex
+
+  ; decimal format
+	clt				; flag of val == 0
+.L_dec_loop:
+	push	v_lo			; to calculate remander
+  ; val &= ~1
+	andi	v_lo, ~1
+  ; val += 2
+	subi	v_lo, lo8(-2)
+	sbci	v_hi, hi8(-2)
+	sbci	v_hlo, hlo8(-2)
+	sbci	v_hhi, hhi8(-2)
+	sbci	v_fifth, hhi8(-2)
+  ; val += val/2
+	ldi	cnt, 1
+	rcall	.L_div_add
+  ; val += val/16
+	ldi	cnt, 4
+	rcall	.L_div_add
+  ; val += val/256
+	add	v_lo, v_hi
+	adc	v_hi, v_hlo
+	adc	v_hlo, v_hhi
+	adc	v_hhi, v_fifth
+	adc	v_fifth, rzero
+  ; val += val/65536
+	add	v_lo, v_hlo
+	adc	v_hi, v_hhi
+	adc	v_hlo, v_fifth
+	adc	v_hhi, rzero
+	adc	v_fifth, rzero
+  ; val += val >> 32
+	add	v_lo, v_fifth
+	adc	v_hi, rzero
+	adc	v_hlo, rzero
+	adc	v_hhi, rzero
+	adc	v_fifth, rzero
+  ; division result:  val /= 16
+	rcall	.L_lsr_4		; v_fitth := 0
+	brne	1f
+	set				; T := Z flag
+1:
+  ; rem:  val_original - 10*val
+	pop	t_hi
+#if  defined(__AVR_ENHANCED__) && __AVR_ENHANCED__
+	ldi	t_lo, 10
+	mul	t_lo, v_lo
+	clr	r1
+#else
+	mov	r0, v_lo
+	lsl	r0
+	sub	t_hi, r0
+	lsl	r0
+	lsl	r0
+#endif
+	sub	t_hi, r0
+  ; output digit
+	subi	t_hi, lo8(-'0')
+	st	Z+, t_hi
+  ; quotient == 0 ?
+	brtc	.L_dec_loop
+  ; end of string
+.L_eos:
+	X_movw	r24, ZL
+	ret
+
+  ; octal format
+.L_oct:
+	mov	symb, v_lo
+	andi	symb, 7
+	subi	symb, lo8(-'0')
+	st	Z+, symb
+	ldi	cnt, 3
+	rcall	.L_lsr
+	brne	.L_oct
+	rjmp	.L_eos
+
+  ; hex format
+.L_hex:
+	mov	symb, v_lo
+	andi	symb, 0x0f
+	subi	symb, lo8(-'0')
+	cpi	symb, '9' + 1
+	brlo	3f
+	subi	symb, lo8('9' + 1 - 'a')
+	sbrc	flags, ntz(XTOA_UPPER) - 8
+	subi	symb, lo8('a' - 'A')
+3:	st	Z+, symb
+	rcall	.L_lsr_4
+	brne	.L_hex
+	rjmp	.L_eos
+	
+.L_lsr_4:
+	ldi	cnt, 4
+.L_lsr:
+	lsr	v_fifth
+	ror	v_hhi
+	ror	v_hlo
+	ror	v_hi
+	ror	v_lo
+	dec	cnt
+	brne	.L_lsr
+  ; tst
+	sbiw	v_hlo, 0		; only Z flag is needed
+	cpc	v_lo, rzero
+	cpc	v_hi, rzero
+	ret
+
+.L_div_add:
+  ; copy to temporary
+	X_movw	t_lo, v_lo
+	X_movw	t_hlo, v_hlo
+	mov	r0, v_fifth
+  ; lsr temporary
+7:	lsr	r0
+	ror	t_hhi
+	ror	t_hlo
+	ror	t_hi
+	ror	t_lo
+	dec	cnt
+	brne	7b
+  ; add
+	add	v_lo, t_lo
+	adc	v_hi, t_hi
+	adc	v_hlo, t_hlo
+	adc	v_hhi, t_hhi
+	adc	v_fifth, r0		; here r0 == 0
+	ret
+
+	.size	__ultoa_invert, . - __ultoa_invert
+	.end
+
+#endif	/* !__DOXYGEN__ */
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/vprintf.cpp DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/vprintf.cpp
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/vprintf.cpp	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/vprintf.cpp	2016-04-18 12:43:02.478226980 +0500
@@ -0,0 +1,532 @@
+// -*- Mode: C++; c-basic-offset: 8; indent-tabs-mode: nil -*-
+/*
+   Adapted from the avr-libc vfprintf:
+
+   Copyright (c) 2002, Alexander Popov (sasho@vip.bg)
+   Copyright (c) 2002,2004,2005 Joerg Wunsch
+   Copyright (c) 2005, Helmut Wallner
+   Copyright (c) 2007, Dmitry Xmelkov
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+   * Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in
+   the documentation and/or other materials provided with the
+   distribution.
+   * Neither the name of the copyright holders nor the names of
+   contributors may be used to endorse or promote products derived
+   from this software without specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/* From: Id: printf_p_new.c,v 1.1.1.9 2002/10/15 20:10:28 joerg_wunsch Exp */
+/* $Id: vfprintf.c,v 1.18.2.1 2009/04/01 23:12:06 arcanum Exp $ */
+
+//#include "SingleSerial.h"
+#define HardwareSerial_h
+
+#include "BetterStream.h"
+
+#include <avr/pgmspace.h>
+#include <stdarg.h>
+#include <string.h>
+extern "C" {
+#include "ftoa_engine.h"
+#include "ntz.h"
+#include "xtoa_fast.h"
+}
+
+#define GETBYTE(flag, mask, pnt)        ({                              \
+                        unsigned char __c;                              \
+                        asm (                                           \
+                             "sbrc      %2,%3   \n\t"                   \
+                             "lpm       %0,Z+   \n\t"                   \
+                             "sbrs      %2,%3   \n\t"                   \
+                             "ld        %0,Z+   "                       \
+                             : "=r" (__c),                              \
+                               "+z" (pnt)                               \
+                             : "r" (flag),                              \
+                               "I" (ntz(mask))                          \
+                        );                                              \
+                        __c;                                            \
+                })
+
+#define FL_ZFILL	0x01
+#define FL_PLUS		0x02
+#define FL_SPACE	0x04
+#define FL_LPAD		0x08
+#define FL_ALT		0x10
+#define FL_WIDTH	0x20
+#define FL_PREC		0x40
+#define FL_LONG		0x80
+
+#define FL_PGMSTRING	FL_LONG
+#define FL_NEGATIVE	FL_LONG
+
+#define FL_ALTUPP	FL_PLUS
+#define FL_ALTHEX	FL_SPACE
+
+#define	FL_FLTUPP	FL_ALT
+#define FL_FLTEXP	FL_PREC
+#define	FL_FLTFIX	FL_LONG
+
+#ifdef DESKTOP_BUILD
+void
+BetterStream::_vprintf (unsigned char in_progmem, const char *fmt, va_list ap)
+{
+        char *str = NULL;
+        int i;
+        char *fmt2 = strdup(fmt);
+        for (i=0; fmt2[i]; i++) {
+                // cope with %S
+                if (fmt2[i] == '%' && fmt2[i+1] == 'S') {
+                        fmt2[i+1] = 's';
+                }
+        }
+        vasprintf(&str, fmt2, ap);
+        for (i=0; str[i]; i++) {
+                _write(str[i]);
+        }
+        free(str);
+        free(fmt2);
+}
+#else
+void
+BetterStream::_vprintf (unsigned char in_progmem, const char *fmt, va_list ap)
+{
+        unsigned char c;        /* holds a char from the format string */
+        unsigned char flags;
+        unsigned char width;
+        unsigned char prec;
+        unsigned char buf[11];  /* size for -1 in octal, without '\0'   */
+
+        for (;;) {
+
+                /*
+                 * Process non-format characters
+                 */
+                for (;;) {
+                        c = GETBYTE (in_progmem, 1, fmt);
+                        if (!c) return;
+                        if (c == '%') {
+                                c = GETBYTE (in_progmem, 1, fmt);
+                                if (c != '%') break;
+                        }
+                        /* emit cr before lf to make most terminals happy */
+                        if (c == '\n')
+                                _write('\r');
+                        _write(c);
+                }
+
+                flags = 0;
+                width = 0;
+                prec = 0;
+                
+                /*
+                 * Process format adjustment characters, precision, width.
+                 */
+                do {
+                        if (flags < FL_WIDTH) {
+                                switch (c) {
+                                case '0':
+                                        flags |= FL_ZFILL;
+                                        continue;
+                                case '+':
+                                        flags |= FL_PLUS;
+                                        /* FALLTHROUGH */
+                                case ' ':
+                                        flags |= FL_SPACE;
+                                        continue;
+                                case '-':
+                                        flags |= FL_LPAD;
+                                        continue;
+                                case '#':
+                                        flags |= FL_ALT;
+                                        continue;
+                                }
+                        }
+
+                        if (flags < FL_LONG) {
+                                if (c >= '0' && c <= '9') {
+                                        c -= '0';
+                                        if (flags & FL_PREC) {
+                                                prec = 10*prec + c;
+                                                continue;
+                                        }
+                                        width = 10*width + c;
+                                        flags |= FL_WIDTH;
+                                        continue;
+                                }
+                                if (c == '.') {
+                                        if (flags & FL_PREC)
+                                                return;
+                                        flags |= FL_PREC;
+                                        continue;
+                                }
+                                if (c == 'l') {
+                                        flags |= FL_LONG;
+                                        continue;
+                                }
+                                if (c == 'h')
+                                        continue;
+                        }
+            
+                        break;
+                } while ( (c = GETBYTE (in_progmem, 1, fmt)) != 0);
+
+#if !defined( SKIP_FLOAT )
+                /*
+                 * Handle floating-point formats E, F, G, e, f, g.
+                 */
+                if (c >= 'E' && c <= 'G') {
+                        flags |= FL_FLTUPP;
+                        c += 'e' - 'E';
+                        goto flt_oper;
+
+                } else if (c >= 'e' && c <= 'g') {
+
+                        int exp;                /* exponent of master decimal digit     */
+                        int n;
+                        unsigned char vtype;    /* result of float value parse  */
+                        unsigned char sign;     /* sign character (or 0)        */
+                        unsigned char ndigs;
+
+                        flags &= ~FL_FLTUPP;
+
+                flt_oper:
+                        if (!(flags & FL_PREC))
+                                prec = 6;
+                        flags &= ~(FL_FLTEXP | FL_FLTFIX);
+                        if (c == 'e')
+                                flags |= FL_FLTEXP;
+                        else if (c == 'f')
+                                flags |= FL_FLTFIX;
+                        else if (prec > 0)
+                                prec -= 1;
+
+                        if (flags & FL_FLTFIX) {
+                                vtype = 7;              /* 'prec' arg for 'ftoa_engine' */
+                                ndigs = prec < 60 ? prec + 1 : 60;
+                        } else {
+                                if (prec > 7) prec = 7;
+                                vtype = prec;
+                                ndigs = 0;
+                        }
+                        exp = __ftoa_engine (va_arg(ap,double), (char *)buf, vtype, ndigs);
+                        vtype = buf[0];
+    
+                        sign = 0;
+                        if ((vtype & FTOA_MINUS) && !(vtype & FTOA_NAN))
+                                sign = '-';
+                        else if (flags & FL_PLUS)
+                                sign = '+';
+                        else if (flags & FL_SPACE)
+                                sign = ' ';
+
+                        if (vtype & (FTOA_NAN | FTOA_INF)) {
+                                const char *p;
+                                ndigs = sign ? 4 : 3;
+                                if (width > ndigs) {
+                                        width -= ndigs;
+                                        if (!(flags & FL_LPAD)) {
+                                                do {
+                                                        _write(' ');
+                                                } while (--width);
+                                        }
+                                } else {
+                                        width = 0;
+                                }
+                                if (sign)
+                                        _write(sign);
+                                p = PSTR("inf");
+                                if (vtype & FTOA_NAN)
+                                        p = PSTR("nan");
+                                while ( (ndigs = pgm_read_byte((const prog_char *)p)) != 0) {
+                                        if (flags & FL_FLTUPP)
+                                                ndigs += 'I' - 'i';
+                                        _write(ndigs);
+                                        p++;
+                                }
+                                goto tail;
+                        }
+
+                        /* Output format adjustment, number of decimal digits in buf[] */
+                        if (flags & FL_FLTFIX) {
+                                ndigs += exp;
+                                if ((vtype & FTOA_CARRY) && buf[1] == '1')
+                                        ndigs -= 1;
+                                if ((signed char)ndigs < 1)
+                                        ndigs = 1;
+                                else if (ndigs > 8)
+                                        ndigs = 8;
+                        } else if (!(flags & FL_FLTEXP)) {              /* 'g(G)' format */
+                                if (exp <= prec && exp >= -4)
+                                        flags |= FL_FLTFIX;
+                                while (prec && buf[1+prec] == '0')
+                                        prec--;
+                                if (flags & FL_FLTFIX) {
+                                        ndigs = prec + 1;               /* number of digits in buf */
+                                        prec = prec > exp
+                                                ? prec - exp : 0;       /* fractional part length  */
+                                }
+                        }
+    
+                        /* Conversion result length, width := free space length */
+                        if (flags & FL_FLTFIX)
+                                n = (exp>0 ? exp+1 : 1);
+                        else
+                                n = 5;          /* 1e+00 */
+                        if (sign) n += 1;
+                        if (prec) n += prec + 1;
+                        width = width > n ? width - n : 0;
+    
+                        /* Output before first digit    */
+                        if (!(flags & (FL_LPAD | FL_ZFILL))) {
+                                while (width) {
+                                        _write(' ');
+                                        width--;
+                                }
+                        }
+                        if (sign) _write(sign);
+                        if (!(flags & FL_LPAD)) {
+                                while (width) {
+                                        _write('0');
+                                        width--;
+                                }
+                        }
+    
+                        if (flags & FL_FLTFIX) {                /* 'f' format           */
+
+                                n = exp > 0 ? exp : 0;          /* exponent of left digit */
+                                do {
+                                        if (n == -1)
+                                                _write('.');
+                                        flags = (n <= exp && n > exp - ndigs)
+                                                ? buf[exp - n + 1] : '0';
+                                        if (--n < -prec)
+                                                break;
+                                        _write(flags);
+                                } while (1);
+                                if (n == exp
+                                    && (buf[1] > '5'
+                                        || (buf[1] == '5' && !(vtype & FTOA_CARRY))) )
+                                        {
+                                                flags = '1';
+                                        }
+                                _write(flags);
+        
+                        } else {                                /* 'e(E)' format        */
+
+                                /* mantissa     */
+                                if (buf[1] != '1')
+                                        vtype &= ~FTOA_CARRY;
+                                _write(buf[1]);
+                                if (prec) {
+                                        _write('.');
+                                        sign = 2;
+                                        do {
+                                                _write(buf[sign++]);
+                                        } while (--prec);
+                                }
+
+                                /* exponent     */
+                                _write(flags & FL_FLTUPP ? 'E' : 'e');
+                                ndigs = '+';
+                                if (exp < 0 || (exp == 0 && (vtype & FTOA_CARRY) != 0)) {
+                                        exp = -exp;
+                                        ndigs = '-';
+                                }
+                                _write(ndigs);
+                                for (ndigs = '0'; exp >= 10; exp -= 10)
+                                        ndigs += 1;
+                                _write(ndigs);
+                                _write('0' + exp);
+                        }
+
+                        goto tail;
+                }
+#endif
+                /*
+                 * Handle string formats c, s, S.
+                 */
+                {
+                        const char * pnt;
+                        size_t size;
+
+                        switch (c) {
+
+                        case 'c':
+                                buf[0] = va_arg (ap, int);
+                                pnt = (char *)buf;
+                                size = 1;
+                                goto no_pgmstring;
+
+                        case 's':
+                                pnt = va_arg (ap, char *);
+                                size = strnlen (pnt, (flags & FL_PREC) ? prec : ~0);
+                        no_pgmstring:
+                                flags &= ~FL_PGMSTRING;
+                                goto str_lpad;
+
+                        case 'S':
+                        // pgmstring: // not yet used
+                                pnt = va_arg (ap, char *);
+                                size = strnlen_P (pnt, (flags & FL_PREC) ? prec : ~0);
+                                flags |= FL_PGMSTRING;
+
+                        str_lpad:
+                                if (!(flags & FL_LPAD)) {
+                                        while (size < width) {
+                                                _write(' ');
+                                                width--;
+                                        }
+                                }
+                                while (size) {
+                                        _write(GETBYTE (flags, FL_PGMSTRING, pnt));
+                                        if (width) width -= 1;
+                                        size -= 1;
+                                }
+                                goto tail;
+                        }
+                }
+
+                /*
+                 * Handle integer formats variations for d/i, u, o, p, x, X.
+                 */
+                if (c == 'd' || c == 'i') {
+                        long x = (flags & FL_LONG) ? va_arg(ap,long) : va_arg(ap,int);
+                        flags &= ~(FL_NEGATIVE | FL_ALT);
+                        if (x < 0) {
+                                x = -x;
+                                flags |= FL_NEGATIVE;
+                        }
+                        c = __ultoa_invert (x, (char *)buf, 10) - (char *)buf;
+
+                } else {
+                        int base;
+
+                        if (c == 'u') {
+                                flags &= ~FL_ALT;
+                                base = 10;
+                                goto ultoa;
+                        }
+
+                        flags &= ~(FL_PLUS | FL_SPACE);
+
+                        switch (c) {
+                        case 'o':
+                                base = 8;
+                                goto ultoa;
+                        case 'p':
+                                flags |= FL_ALT;
+                                /* no break */
+                        case 'x':
+                                if (flags & FL_ALT)
+                                        flags |= FL_ALTHEX;
+                                base = 16;
+                                goto ultoa;
+                        case 'X':
+                                if (flags & FL_ALT)
+                                        flags |= (FL_ALTHEX | FL_ALTUPP);
+                                base = 16 | XTOA_UPPER;
+                        ultoa:
+                                c = __ultoa_invert ((flags & FL_LONG)
+                                                    ? va_arg(ap, unsigned long)
+                                                    : va_arg(ap, unsigned int),
+                                                    (char *)buf, base)  -  (char *)buf;
+                                flags &= ~FL_NEGATIVE;
+                                break;
+
+                        default:
+                                return;
+                        }
+                }
+
+                /*
+                 * Format integers.
+                 */
+                {
+                        unsigned char len;
+
+                        len = c;
+                        if (flags & FL_PREC) {
+                                flags &= ~FL_ZFILL;
+                                if (len < prec) {
+                                        len = prec;
+                                        if ((flags & FL_ALT) && !(flags & FL_ALTHEX))
+                                                flags &= ~FL_ALT;
+                                }
+                        }
+                        if (flags & FL_ALT) {
+                                if (buf[c-1] == '0') {
+                                        flags &= ~(FL_ALT | FL_ALTHEX | FL_ALTUPP);
+                                } else {
+                                        len += 1;
+                                        if (flags & FL_ALTHEX)
+                                                len += 1;
+                                }
+                        } else if (flags & (FL_NEGATIVE | FL_PLUS | FL_SPACE)) {
+                                len += 1;
+                        }
+
+                        if (!(flags & FL_LPAD)) {
+                                if (flags & FL_ZFILL) {
+                                        prec = c;
+                                        if (len < width) {
+                                                prec += width - len;
+                                                len = width;
+                                        }
+                                }
+                                while (len < width) {
+                                        _write(' ');
+                                        len++;
+                                }
+                        }
+        
+                        width =  (len < width) ? width - len : 0;
+
+                        if (flags & FL_ALT) {
+                                _write('0');
+                                if (flags & FL_ALTHEX)
+                                        _write(flags & FL_ALTUPP ? 'X' : 'x');
+                        } else if (flags & (FL_NEGATIVE | FL_PLUS | FL_SPACE)) {
+                                unsigned char z = ' ';
+                                if (flags & FL_PLUS) z = '+';
+                                if (flags & FL_NEGATIVE) z = '-';
+                                _write(z);
+                        }
+                
+                        while (prec > c) {
+                                _write('0');
+                                prec--;
+                        }
+        
+                        do {
+                                _write(buf[--c]);
+                        } while (c);
+                }
+        
+        tail:
+                /* Tail is possible.    */
+                while (width) {
+                        _write(' ');
+                        width--;
+                }
+        } /* for (;;) */
+}
+#endif // DESKTOP_BUILD
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/wiring.h DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/wiring.h
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/wiring.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/wiring.h	2016-03-01 12:18:48.872102924 +0500
@@ -0,0 +1,136 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <avr/io.h>
+#include <stdlib.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(DESKTOP_BUILD)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+//#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
+#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+#define bit_is_set(value, bit) (((value) & bit) != 0)
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+//typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+uint8_t digitalRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+int abs(int v);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+void setup(void);
+void loop(void);
+long map(long , long , long , long , long );
+
+#endif
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/WProgram.h DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/WProgram.h
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/WProgram.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/WProgram.h	2015-12-11 11:00:15.000000000 +0500
@@ -0,0 +1,30 @@
+#ifndef WProgram_h
+#define WProgram_h
+
+#define HardwareSerial_h
+#include "wiring.h"
+#include <stdarg.h>
+#include "HardwareSerial.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <unistd.h>
+#include <stdint.h>
+
+typedef uint8_t byte;
+
+void delay(unsigned long msec);
+char *itoa(int __val, char *__s, int __radix);
+char *ltoa(long __val, char *__s, int __radix);
+char *ultoa(unsigned long __val, char *__s, int __radix);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/SingleSerial/xtoa_fast.h DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/xtoa_fast.h
--- DIY_Headtracker_Firmware_orig/libraries/SingleSerial/xtoa_fast.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/SingleSerial/xtoa_fast.h	2015-02-17 19:04:31.000000000 +0500
@@ -0,0 +1,48 @@
+/*
+   Adapted from avr-libc:
+
+   Copyright (c) 2005, Dmitry Xmelkov
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: xtoa_fast.h 1223 2007-02-18 13:33:09Z dmix $	*/
+
+#ifndef	_XTOA_FAST_H_
+#define _XTOA_FAST_H_
+
+#ifndef	__ASSEMBLER__
+
+/* Internal function for use from `printf'.	*/
+char * __ultoa_invert (unsigned long val, char *s, int base);
+
+#endif	/* ifndef __ASSEMBLER__ */
+
+/* Next flags are to use with `base'. Unused fields are reserved.	*/
+#define XTOA_PREFIX	0x0100	/* put prefix for octal or hex	*/
+#define XTOA_UPPER	0x0200	/* use upper case letters	*/
+
+#endif	/* _XTOA_FAST_H_ */
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/Wire/utility/twi.c DIY_Headtracker_Firmware_fastserial/libraries/Wire/utility/twi.c
--- DIY_Headtracker_Firmware_orig/libraries/Wire/utility/twi.c	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/Wire/utility/twi.c	2015-11-03 20:07:55.000000000 +0500
@@ -0,0 +1,545 @@
+/*
+  twi.c - TWI/I2C library for Wiring & Arduino
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts
+*/
+
+#include <math.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <compat/twi.h>
+#include "Arduino.h" // for digitalWrite
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#include "pins_arduino.h"
+#include "twi.h"
+
+static volatile uint8_t twi_state;
+static volatile uint8_t twi_slarw;
+static volatile uint8_t twi_sendStop;			// should the transaction end with a stop
+static volatile uint8_t twi_inRepStart;			// in the middle of a repeated start
+
+static void (*twi_onSlaveTransmit)(void);
+static void (*twi_onSlaveReceive)(uint8_t*, int);
+
+static uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];
+static volatile uint8_t twi_masterBufferIndex;
+static volatile uint8_t twi_masterBufferLength;
+
+static uint8_t twi_txBuffer[TWI_BUFFER_LENGTH];
+static volatile uint8_t twi_txBufferIndex;
+static volatile uint8_t twi_txBufferLength;
+
+static uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];
+static volatile uint8_t twi_rxBufferIndex;
+
+static volatile uint8_t twi_error;
+
+/* 
+ * Function twi_init
+ * Desc     readys twi pins and sets twi bitrate
+ * Input    none
+ * Output   none
+ */
+void twi_init(void)
+{
+  // initialize state
+  twi_state = TWI_READY;
+  twi_sendStop = true;		// default value
+  twi_inRepStart = false;
+  
+  // activate internal pullups for twi.
+  digitalWrite(SDA, 1);
+  digitalWrite(SCL, 1);
+
+  // initialize twi prescaler and bit rate
+  cbi(TWSR, TWPS0);
+  cbi(TWSR, TWPS1);
+  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;
+
+  /* twi bit rate formula from atmega128 manual pg 204
+  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
+  note: TWBR should be 10 or higher for master mode
+  It is 72 for a 16mhz Wiring board with 100kHz TWI */
+
+  // enable twi module, acks, and twi interrupt
+  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
+}
+
+/* 
+ * Function twi_disable
+ * Desc     disables twi pins
+ * Input    none
+ * Output   none
+ */
+void twi_disable(void)
+{
+  // disable twi module, acks, and twi interrupt
+  TWCR &= ~(_BV(TWEN) | _BV(TWIE) | _BV(TWEA));
+
+  // deactivate internal pullups for twi.
+  digitalWrite(SDA, 0);
+  digitalWrite(SCL, 0);
+}
+
+/* 
+ * Function twi_slaveInit
+ * Desc     sets slave address and enables interrupt
+ * Input    none
+ * Output   none
+ */
+void twi_setAddress(uint8_t address)
+{
+  // set twi slave address (skip over TWGCE bit)
+  TWAR = address << 1;
+}
+
+/* 
+ * Function twi_readFrom
+ * Desc     attempts to become twi bus master and read a
+ *          series of bytes from a device on the bus
+ * Input    address: 7bit i2c device address
+ *          data: pointer to byte array
+ *          length: number of bytes to read into array
+ *          sendStop: Boolean indicating whether to send a stop at the end
+ * Output   number of bytes read
+ */
+uint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length, uint8_t sendStop)
+{
+  uint8_t i;
+
+  // ensure data will fit into buffer
+  if(TWI_BUFFER_LENGTH < length){
+    return 0;
+  }
+
+  // wait until twi is ready, become master receiver
+  while(TWI_READY != twi_state){
+    continue;
+  }
+  twi_state = TWI_MRX;
+  twi_sendStop = sendStop;
+  // reset error state (0xFF.. no error occured)
+  twi_error = 0xFF;
+
+  // initialize buffer iteration vars
+  twi_masterBufferIndex = 0;
+  twi_masterBufferLength = length-1;  // This is not intuitive, read on...
+  // On receive, the previously configured ACK/NACK setting is transmitted in
+  // response to the received byte before the interrupt is signalled. 
+  // Therefor we must actually set NACK when the _next_ to last byte is
+  // received, causing that NACK to be sent in response to receiving the last
+  // expected byte of data.
+
+  // build sla+w, slave device address + w bit
+  twi_slarw = TW_READ;
+  twi_slarw |= address << 1;
+
+  if (true == twi_inRepStart) {
+    // if we're in the repeated start state, then we've already sent the start,
+    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
+    // We need to remove ourselves from the repeated start state before we enable interrupts,
+    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
+    // up. Also, don't enable the START interrupt. There may be one pending from the 
+    // repeated start that we sent outselves, and that would really confuse things.
+    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
+    do {
+      TWDR = twi_slarw;
+    } while(TWCR & _BV(TWWC));
+    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
+  }
+  else
+    // send start condition
+    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
+
+  // wait for read operation to complete
+  while(TWI_MRX == twi_state){
+    continue;
+  }
+
+  if (twi_masterBufferIndex < length)
+    length = twi_masterBufferIndex;
+
+  // copy twi buffer to data
+  for(i = 0; i < length; ++i){
+    data[i] = twi_masterBuffer[i];
+  }
+	
+  return length;
+}
+
+/* 
+ * Function twi_writeTo
+ * Desc     attempts to become twi bus master and write a
+ *          series of bytes to a device on the bus
+ * Input    address: 7bit i2c device address
+ *          data: pointer to byte array
+ *          length: number of bytes in array
+ *          wait: boolean indicating to wait for write or not
+ *          sendStop: boolean indicating whether or not to send a stop at the end
+ * Output   0 .. success
+ *          1 .. length to long for buffer
+ *          2 .. address send, NACK received
+ *          3 .. data send, NACK received
+ *          4 .. other twi error (lost bus arbitration, bus error, ..)
+ */
+uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
+{
+  uint8_t i;
+
+  // ensure data will fit into buffer
+  if(TWI_BUFFER_LENGTH < length){
+    return 1;
+  }
+
+  // wait until twi is ready, become master transmitter
+  while(TWI_READY != twi_state){
+    continue;
+  }
+  twi_state = TWI_MTX;
+  twi_sendStop = sendStop;
+  // reset error state (0xFF.. no error occured)
+  twi_error = 0xFF;
+
+  // initialize buffer iteration vars
+  twi_masterBufferIndex = 0;
+  twi_masterBufferLength = length;
+  
+  // copy data to twi buffer
+  for(i = 0; i < length; ++i){
+    twi_masterBuffer[i] = data[i];
+  }
+  
+  // build sla+w, slave device address + w bit
+  twi_slarw = TW_WRITE;
+  twi_slarw |= address << 1;
+  
+  // if we're in a repeated start, then we've already sent the START
+  // in the ISR. Don't do it again.
+  //
+  if (true == twi_inRepStart) {
+    // if we're in the repeated start state, then we've already sent the start,
+    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
+    // We need to remove ourselves from the repeated start state before we enable interrupts,
+    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
+    // up. Also, don't enable the START interrupt. There may be one pending from the 
+    // repeated start that we sent outselves, and that would really confuse things.
+    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
+    do {
+      TWDR = twi_slarw;				
+    } while(TWCR & _BV(TWWC));
+    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
+  }
+  else
+    // send start condition
+    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs
+
+  // wait for write operation to complete
+  while(wait && (TWI_MTX == twi_state)){
+    continue;
+  }
+  
+  if (twi_error == 0xFF)
+    return 0;	// success
+  else if (twi_error == TW_MT_SLA_NACK)
+    return 2;	// error: address send, nack received
+  else if (twi_error == TW_MT_DATA_NACK)
+    return 3;	// error: data send, nack received
+  else
+    return 4;	// other twi error
+}
+
+/* 
+ * Function twi_transmit
+ * Desc     fills slave tx buffer with data
+ *          must be called in slave tx event callback
+ * Input    data: pointer to byte array
+ *          length: number of bytes in array
+ * Output   1 length too long for buffer
+ *          2 not slave transmitter
+ *          0 ok
+ */
+uint8_t twi_transmit(const uint8_t* data, uint8_t length)
+{
+  uint8_t i;
+
+  // ensure data will fit into buffer
+  if(TWI_BUFFER_LENGTH < length){
+    return 1;
+  }
+  
+  // ensure we are currently a slave transmitter
+  if(TWI_STX != twi_state){
+    return 2;
+  }
+  
+  // set length and copy data into tx buffer
+  twi_txBufferLength = length;
+  for(i = 0; i < length; ++i){
+    twi_txBuffer[i] = data[i];
+  }
+  
+  return 0;
+}
+
+/* 
+ * Function twi_attachSlaveRxEvent
+ * Desc     sets function called before a slave read operation
+ * Input    function: callback function to use
+ * Output   none
+ */
+void twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )
+{
+  twi_onSlaveReceive = function;
+}
+
+/* 
+ * Function twi_attachSlaveTxEvent
+ * Desc     sets function called before a slave write operation
+ * Input    function: callback function to use
+ * Output   none
+ */
+void twi_attachSlaveTxEvent( void (*function)(void) )
+{
+  twi_onSlaveTransmit = function;
+}
+
+/* 
+ * Function twi_reply
+ * Desc     sends byte or readys receive line
+ * Input    ack: byte indicating to ack or to nack
+ * Output   none
+ */
+void twi_reply(uint8_t ack)
+{
+  // transmit master read ready signal, with or without ack
+  if(ack){
+    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
+  }else{
+	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
+  }
+}
+
+/* 
+ * Function twi_stop
+ * Desc     relinquishes bus master status
+ * Input    none
+ * Output   none
+ */
+void twi_stop(void)
+{
+  // send stop condition
+  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
+
+  // wait for stop condition to be exectued on bus
+  // TWINT is not set after a stop condition!
+  while(TWCR & _BV(TWSTO)){
+    continue;
+  }
+
+  // update twi state
+  twi_state = TWI_READY;
+}
+
+/* 
+ * Function twi_releaseBus
+ * Desc     releases bus control
+ * Input    none
+ * Output   none
+ */
+void twi_releaseBus(void)
+{
+  // release bus
+  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
+
+  // update twi state
+  twi_state = TWI_READY;
+}
+
+ISR(TWI_vect)
+{
+  switch(TW_STATUS){
+    // All Master
+    case TW_START:     // sent start condition
+    case TW_REP_START: // sent repeated start condition
+      // copy device address and r/w bit to output register and ack
+      TWDR = twi_slarw;
+      twi_reply(1);
+      break;
+
+    // Master Transmitter
+    case TW_MT_SLA_ACK:  // slave receiver acked address
+    case TW_MT_DATA_ACK: // slave receiver acked data
+      // if there is data to send, send it, otherwise stop 
+      if(twi_masterBufferIndex < twi_masterBufferLength){
+        // copy data to output register and ack
+        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
+        twi_reply(1);
+      }else{
+	if (twi_sendStop)
+          twi_stop();
+	else {
+	  twi_inRepStart = true;	// we're gonna send the START
+	  // don't enable the interrupt. We'll generate the start, but we 
+	  // avoid handling the interrupt until we're in the next transaction,
+	  // at the point where we would normally issue the start.
+	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
+	  twi_state = TWI_READY;
+	}
+      }
+      break;
+    case TW_MT_SLA_NACK:  // address sent, nack received
+      twi_error = TW_MT_SLA_NACK;
+      twi_stop();
+      break;
+    case TW_MT_DATA_NACK: // data sent, nack received
+      twi_error = TW_MT_DATA_NACK;
+      twi_stop();
+      break;
+    case TW_MT_ARB_LOST: // lost bus arbitration
+      twi_error = TW_MT_ARB_LOST;
+      twi_releaseBus();
+      break;
+
+    // Master Receiver
+    case TW_MR_DATA_ACK: // data received, ack sent
+      // put byte into buffer
+      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
+    case TW_MR_SLA_ACK:  // address sent, ack received
+      // ack if more bytes are expected, otherwise nack
+      if(twi_masterBufferIndex < twi_masterBufferLength){
+        twi_reply(1);
+      }else{
+        twi_reply(0);
+      }
+      break;
+    case TW_MR_DATA_NACK: // data received, nack sent
+      // put final byte into buffer
+      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
+	if (twi_sendStop)
+          twi_stop();
+	else {
+	  twi_inRepStart = true;	// we're gonna send the START
+	  // don't enable the interrupt. We'll generate the start, but we 
+	  // avoid handling the interrupt until we're in the next transaction,
+	  // at the point where we would normally issue the start.
+	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
+	  twi_state = TWI_READY;
+	}    
+	break;
+    case TW_MR_SLA_NACK: // address sent, nack received
+      twi_stop();
+      break;
+    // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case
+
+    // Slave Receiver
+    case TW_SR_SLA_ACK:   // addressed, returned ack
+    case TW_SR_GCALL_ACK: // addressed generally, returned ack
+    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
+    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
+      // enter slave receiver mode
+      twi_state = TWI_SRX;
+      // indicate that rx buffer can be overwritten and ack
+      twi_rxBufferIndex = 0;
+      twi_reply(1);
+      break;
+    case TW_SR_DATA_ACK:       // data received, returned ack
+    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
+      // if there is still room in the rx buffer
+      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
+        // put byte in buffer and ack
+        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
+        twi_reply(1);
+      }else{
+        // otherwise nack
+        twi_reply(0);
+      }
+      break;
+    case TW_SR_STOP: // stop or repeated start condition received
+      // ack future responses and leave slave receiver state
+      twi_releaseBus();
+      // put a null char after data if there's room
+      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
+        twi_rxBuffer[twi_rxBufferIndex] = '\0';
+      }
+      // callback to user defined callback
+      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
+      // since we submit rx buffer to "wire" library, we can reset it
+      twi_rxBufferIndex = 0;
+      break;
+    case TW_SR_DATA_NACK:       // data received, returned nack
+    case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack
+      // nack back at master
+      twi_reply(0);
+      break;
+    
+    // Slave Transmitter
+    case TW_ST_SLA_ACK:          // addressed, returned ack
+    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
+      // enter slave transmitter mode
+      twi_state = TWI_STX;
+      // ready the tx buffer index for iteration
+      twi_txBufferIndex = 0;
+      // set tx buffer length to be zero, to verify if user changes it
+      twi_txBufferLength = 0;
+      // request for txBuffer to be filled and length to be set
+      // note: user must call twi_transmit(bytes, length) to do this
+      twi_onSlaveTransmit();
+      // if they didn't change buffer & length, initialize it
+      if(0 == twi_txBufferLength){
+        twi_txBufferLength = 1;
+        twi_txBuffer[0] = 0x00;
+      }
+      // transmit first byte from buffer, fall
+    case TW_ST_DATA_ACK: // byte sent, ack returned
+      // copy data to output register
+      TWDR = twi_txBuffer[twi_txBufferIndex++];
+      // if there is more to send, ack, otherwise nack
+      if(twi_txBufferIndex < twi_txBufferLength){
+        twi_reply(1);
+      }else{
+        twi_reply(0);
+      }
+      break;
+    case TW_ST_DATA_NACK: // received nack, we are done 
+    case TW_ST_LAST_DATA: // received ack, but we are done already!
+      // ack future responses
+      twi_reply(1);
+      // leave slave receiver state
+      twi_state = TWI_READY;
+      break;
+
+    // All
+    case TW_NO_INFO:   // no state information
+      break;
+    case TW_BUS_ERROR: // bus error, illegal stop/start
+      twi_error = TW_BUS_ERROR;
+      twi_stop();
+      break;
+  }
+}
+
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/Wire/utility/twi.h DIY_Headtracker_Firmware_fastserial/libraries/Wire/utility/twi.h
--- DIY_Headtracker_Firmware_orig/libraries/Wire/utility/twi.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/Wire/utility/twi.h	2015-11-03 20:07:55.000000000 +0500
@@ -0,0 +1,54 @@
+/*
+  twi.h - TWI/I2C library for Wiring & Arduino
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef twi_h
+#define twi_h
+
+  #include <inttypes.h>
+
+  //#define ATMEGA8
+
+  #ifndef TWI_FREQ
+  #define TWI_FREQ 100000L
+  #endif
+
+  #ifndef TWI_BUFFER_LENGTH
+  #define TWI_BUFFER_LENGTH 32
+  #endif
+
+  #define TWI_READY 0
+  #define TWI_MRX   1
+  #define TWI_MTX   2
+  #define TWI_SRX   3
+  #define TWI_STX   4
+  
+  void twi_init(void);
+  void twi_disable(void);
+  void twi_setAddress(uint8_t);
+  uint8_t twi_readFrom(uint8_t, uint8_t*, uint8_t, uint8_t);
+  uint8_t twi_writeTo(uint8_t, uint8_t*, uint8_t, uint8_t, uint8_t);
+  uint8_t twi_transmit(const uint8_t*, uint8_t);
+  void twi_attachSlaveRxEvent( void (*)(uint8_t*, int) );
+  void twi_attachSlaveTxEvent( void (*)(void) );
+  void twi_reply(uint8_t);
+  void twi_stop(void);
+  void twi_releaseBus(void);
+
+#endif
+
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/Wire/Wire.cpp DIY_Headtracker_Firmware_fastserial/libraries/Wire/Wire.cpp
--- DIY_Headtracker_Firmware_orig/libraries/Wire/Wire.cpp	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/Wire/Wire.cpp	2015-12-28 17:04:57.676476775 +0500
@@ -0,0 +1,330 @@
+/*
+  TwoWire.cpp - TWI/I2C library for Wiring & Arduino
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts
+*/
+
+extern "C" {
+  #include <stdlib.h>
+  #include <string.h>
+  #include <inttypes.h>
+  #include "twi.h"
+}
+
+#include "Wire.h"
+
+// Initialize Class Variables //////////////////////////////////////////////////
+
+uint8_t TwoWire::rxBuffer[BUFFER_LENGTH];
+uint8_t TwoWire::rxBufferIndex = 0;
+uint8_t TwoWire::rxBufferLength = 0;
+
+uint8_t TwoWire::txAddress = 0;
+uint8_t TwoWire::txBuffer[BUFFER_LENGTH];
+uint8_t TwoWire::txBufferIndex = 0;
+uint8_t TwoWire::txBufferLength = 0;
+
+uint8_t TwoWire::transmitting = 0;
+void (*TwoWire::user_onRequest)(void);
+void (*TwoWire::user_onReceive)(int);
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+TwoWire::TwoWire()
+{
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void TwoWire::begin(void)
+{
+  rxBufferIndex = 0;
+  rxBufferLength = 0;
+
+  txBufferIndex = 0;
+  txBufferLength = 0;
+
+  twi_init();
+}
+
+void TwoWire::begin(uint8_t address)
+{
+  twi_setAddress(address);
+  twi_attachSlaveTxEvent(onRequestService);
+  twi_attachSlaveRxEvent(onReceiveService);
+  begin();
+}
+
+void TwoWire::begin(int address)
+{
+  begin((uint8_t)address);
+}
+
+void TwoWire::end(void)
+{
+  twi_disable();
+}
+
+void TwoWire::setClock(uint32_t frequency)
+{
+  TWBR = ((F_CPU / frequency) - 16) / 2;
+}
+
+uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint32_t iaddress, uint8_t isize, uint8_t sendStop)
+{
+  if (isize > 0) {
+  // send internal address; this mode allows sending a repeated start to access
+  // some devices' internal registers. This function is executed by the hardware
+  // TWI module on other processors (for example Due's TWI_IADR and TWI_MMR registers)
+
+  beginTransmission(address);
+
+  // the maximum size of internal address is 3 bytes
+  if (isize > 3){
+    isize = 3;
+  }
+
+  // write internal register address - most significant byte first
+  while (isize-- > 0)
+    write((uint8_t)(iaddress >> (isize*8)));
+  endTransmission(false);
+  }
+
+  // clamp to buffer length
+  if(quantity > BUFFER_LENGTH){
+    quantity = BUFFER_LENGTH;
+  }
+  // perform blocking read into buffer
+  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);
+  // set rx buffer iterator vars
+  rxBufferIndex = 0;
+  rxBufferLength = read;
+
+  return read;
+}
+
+uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop) {
+	return requestFrom((uint8_t)address, (uint8_t)quantity, (uint32_t)0, (uint8_t)0, (uint8_t)sendStop);
+}
+
+uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)
+{
+  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
+}
+
+uint8_t TwoWire::requestFrom(int address, int quantity)
+{
+  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
+}
+
+uint8_t TwoWire::requestFrom(int address, int quantity, int sendStop)
+{
+  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
+}
+
+void TwoWire::beginTransmission(uint8_t address)
+{
+  // indicate that we are transmitting
+  transmitting = 1;
+  // set address of targeted slave
+  txAddress = address;
+  // reset tx buffer iterator vars
+  txBufferIndex = 0;
+  txBufferLength = 0;
+}
+
+void TwoWire::beginTransmission(int address)
+{
+  beginTransmission((uint8_t)address);
+}
+
+//
+//	Originally, 'endTransmission' was an f(void) function.
+//	It has been modified to take one parameter indicating
+//	whether or not a STOP should be performed on the bus.
+//	Calling endTransmission(false) allows a sketch to 
+//	perform a repeated start. 
+//
+//	WARNING: Nothing in the library keeps track of whether
+//	the bus tenure has been properly ended with a STOP. It
+//	is very possible to leave the bus in a hung state if
+//	no call to endTransmission(true) is made. Some I2C
+//	devices will behave oddly if they do not see a STOP.
+//
+uint8_t TwoWire::endTransmission(uint8_t sendStop)
+{
+  // transmit buffer (blocking)
+  int8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);
+  // reset tx buffer iterator vars
+  txBufferIndex = 0;
+  txBufferLength = 0;
+  // indicate that we are done transmitting
+  transmitting = 0;
+  return ret;
+}
+
+//	This provides backwards compatibility with the original
+//	definition, and expected behaviour, of endTransmission
+//
+uint8_t TwoWire::endTransmission(void)
+{
+  return endTransmission(true);
+}
+
+// must be called in:
+// slave tx event callback
+// or after beginTransmission(address)
+size_t TwoWire::write(uint8_t data)
+{
+  if(transmitting){
+  // in master transmitter mode
+    // don't bother if buffer is full
+    if(txBufferLength >= BUFFER_LENGTH){
+      setWriteError();
+      return 0;
+    }
+    // put byte in tx buffer
+    txBuffer[txBufferIndex] = data;
+    ++txBufferIndex;
+    // update amount in buffer   
+    txBufferLength = txBufferIndex;
+  }else{
+  // in slave send mode
+    // reply to master
+    twi_transmit(&data, 1);
+  }
+  return 1;
+}
+
+// must be called in:
+// slave tx event callback
+// or after beginTransmission(address)
+size_t TwoWire::write(const uint8_t *data, size_t quantity)
+{
+  if(transmitting){
+  // in master transmitter mode
+    for(size_t i = 0; i < quantity; ++i){
+      write(data[i]);
+    }
+  }else{
+  // in slave send mode
+    // reply to master
+    twi_transmit(data, quantity);
+  }
+  return quantity;
+}
+
+// must be called in:
+// slave rx event callback
+// or after requestFrom(address, numBytes)
+uint8_t TwoWire::available(void)
+{
+  return rxBufferLength - rxBufferIndex;
+}
+
+// must be called in:
+// slave rx event callback
+// or after requestFrom(address, numBytes)
+uint8_t TwoWire::read(void)
+{
+  int value = -1;
+  
+  // get each successive byte on each call
+  if(rxBufferIndex < rxBufferLength){
+    value = rxBuffer[rxBufferIndex];
+    ++rxBufferIndex;
+  }
+
+  return value;
+}
+
+// must be called in:
+// slave rx event callback
+// or after requestFrom(address, numBytes)
+uint8_t TwoWire::peek(void)
+{
+  int value = -1;
+  
+  if(rxBufferIndex < rxBufferLength){
+    value = rxBuffer[rxBufferIndex];
+  }
+
+  return value;
+}
+
+void TwoWire::flush(void)
+{
+  // XXX: to be implemented.
+}
+
+// behind the scenes function that is called when data is received
+void TwoWire::onReceiveService(uint8_t* inBytes, int numBytes)
+{
+  // don't bother if user hasn't registered a callback
+  if(!user_onReceive){
+    return;
+  }
+  // don't bother if rx buffer is in use by a master requestFrom() op
+  // i know this drops data, but it allows for slight stupidity
+  // meaning, they may not have read all the master requestFrom() data yet
+  if(rxBufferIndex < rxBufferLength){
+    return;
+  }
+  // copy twi rx buffer into local read buffer
+  // this enables new reads to happen in parallel
+  for(uint8_t i = 0; i < numBytes; ++i){
+    rxBuffer[i] = inBytes[i];    
+  }
+  // set rx iterator vars
+  rxBufferIndex = 0;
+  rxBufferLength = numBytes;
+  // alert user program
+  user_onReceive(numBytes);
+}
+
+// behind the scenes function that is called when data is requested
+void TwoWire::onRequestService(void)
+{
+  // don't bother if user hasn't registered a callback
+  if(!user_onRequest){
+    return;
+  }
+  // reset tx buffer iterator vars
+  // !!! this will kill any pending pre-master sendTo() activity
+  txBufferIndex = 0;
+  txBufferLength = 0;
+  // alert user program
+  user_onRequest();
+}
+
+// sets function called on slave write
+void TwoWire::onReceive( void (*function)(int) )
+{
+  user_onReceive = function;
+}
+
+// sets function called on slave read
+void TwoWire::onRequest( void (*function)(void) )
+{
+  user_onRequest = function;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+
+TwoWire Wire = TwoWire();
+
diff -BburpN DIY_Headtracker_Firmware_orig/libraries/Wire/Wire.h DIY_Headtracker_Firmware_fastserial/libraries/Wire/Wire.h
--- DIY_Headtracker_Firmware_orig/libraries/Wire/Wire.h	1970-01-01 05:00:00.000000000 +0500
+++ DIY_Headtracker_Firmware_fastserial/libraries/Wire/Wire.h	2015-12-28 17:06:10.225649468 +0500
@@ -0,0 +1,85 @@
+/*
+  TwoWire.h - TWI/I2C library for Arduino & Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts
+*/
+
+#ifndef TwoWire_h
+#define TwoWire_h
+
+#include <inttypes.h>
+#include "../SingleSerial/MyStream.h"
+
+#define BUFFER_LENGTH 32
+
+// WIRE_HAS_END means Wire has end()
+#define WIRE_HAS_END 1
+
+class TwoWire : public MyStream
+{
+  private:
+    static uint8_t rxBuffer[];
+    static uint8_t rxBufferIndex;
+    static uint8_t rxBufferLength;
+
+    static uint8_t txAddress;
+    static uint8_t txBuffer[];
+    static uint8_t txBufferIndex;
+    static uint8_t txBufferLength;
+
+    static uint8_t transmitting;
+    static void (*user_onRequest)(void);
+    static void (*user_onReceive)(int);
+    static void onRequestService(void);
+    static void onReceiveService(uint8_t*, int);
+  public:
+    TwoWire();
+    void begin();
+    void begin(uint8_t);
+    void begin(int);
+    void end();
+    void setClock(uint32_t);
+    void beginTransmission(uint8_t);
+    void beginTransmission(int);
+    uint8_t endTransmission(void);
+    uint8_t endTransmission(uint8_t);
+    uint8_t requestFrom(uint8_t, uint8_t);
+    uint8_t requestFrom(uint8_t, uint8_t, uint8_t);
+	uint8_t requestFrom(uint8_t, uint8_t, uint32_t, uint8_t, uint8_t);
+    uint8_t requestFrom(int, int);
+    uint8_t requestFrom(int, int, int);
+    virtual size_t write(uint8_t);
+    virtual size_t write(const uint8_t *, size_t);
+    virtual uint8_t available(void);
+    virtual uint8_t read(void);
+    virtual uint8_t peek(void);
+    virtual void flush(void);
+    void onReceive( void (*)(int) );
+    void onRequest( void (*)(void) );
+
+    inline size_t write(unsigned long n) { return write((uint8_t)n); }
+    inline size_t write(long n) { return write((uint8_t)n); }
+    inline size_t write(unsigned int n) { return write((uint8_t)n); }
+    inline size_t write(int n) { return write((uint8_t)n); }
+    using Print::write;
+};
+
+extern TwoWire Wire;
+
+#endif
+
